//
// TB8 - Tiny BASIC for PDP8
// Version 0.01
//
// Project repository at github.com/SmallRoomLabs/TB8
//
// Copyright (c) 2020 Mats Engstrom
// Licensed under the MIT license
//

/NL0000=CLA			/ 0
/NL0001=CLA IAC			/ 1
/NL0002=CLA CLL CML RTL		/ 2
/NL0003=CLA STL IAC RAL		/ 3
/NL0004=CLA CLL IAC RTL		/ 4
/NL0006=CLA STL IAC RTL		/ 6
/NL0100=CLA IAC BSW		/ 100    64(dec)
/NL2000=CLA CLL CML RTR 		/ 2000 1024(dec)
/NL4000=CLA CLL CML RAR		/ 4000 2048(dec)
/NL3777=CLA CLL CMA RAR		/ 3777 2047(dec) 
/NL5777=CLA CLL CMA RTR		/ 5777 3071(dec)
/NL6000=CLA STL IAC RTR		/ 6000 3072(dec)
/NL7775=CLA CLL CMA RTL		/ 7775 4093(dec)
/NL7776=CLA CLL CMA RAL		/ 7776 4094(dec)
NL7777=CLA CMA 			/ 7777 4095(dec)

/NLM3=NL7775			/ -3
/NLM2=NL7776			/ -2
NLM1=NL7777			/ -1


*0	
//					       ___     ___     ___     ___
//					      / _ \   / _ \   / _ \   / _ \
//					     | | | | | | | | | | | | | | | |
//					     | |_| | | |_| | | |_| | | |_| |
//					      \___/   \___/   \___/   \___/
/[
IRQ,	0			/ Placeholder for future IRQ handler
	JMP I IRQ

//                                   _           _       _
//  __/\__   __   __   __ _   _ __  (_)   __ _  | |__   | |   ___   ___
//  \    /   \ \ / /  / _` | | '__| | |  / _` | | '_ \  | |  / _ \ / __|
//  /_  _\    \ V /  | (_| | | |    | | | (_| | | |_) | | | |  __/ \__ \
//    \/       \_/    \__,_| |_|    |_|  \__,_| |_.__/  |_|  \___| |___/
//

Key,	.-.			/ Last read key
KBufL,	.-.			/ Current length of string in KBuf

tmp,;tmp1,	.-.			/ Generic temporary variable
tmp2,;A,;tmpH,	.-.			/ Generic temporary variable
tmp3,;B,;tmpL,	.-.			/ Generic temporary variable

*10
PrintP,	.-.			/ Pointer to string to be printed
KBufP,	.-.			/ Pointer to the first free location in KBuf
iP1,	.-.			/ Generic memory pointer
iP2,	.-.			/ Generic memory pointer

*20
cnt,	.-.			/ Generic counter
cnt2,	.-.
src,	.-.			/ Generic source address
dst,	.-.			/ Generic destination address
ADDRS,  .-. /???
numH, 	.-.
numL,	.-.
lineH,	.-.
lineL,	.-.

Arg1,;Arg1H,	.-.
Arg1L,	.-.
Arg2,;Arg2H,	.-.
Arg2L,	.-.
C,;ResH,	.-.
D,;ResL,		.-.

Ctype,	.-.


// Variables for SDPRINT
SDLOOP,	-7			/COUNT OF SEVEN DIGITS
SDTWO,	260			/BASIC CODE FOR DIGITS
SDPLUS,	-15			/"SPACE". TO TYPE "+",REPLACE BY "-2"
SDMNS,	-3			/"MINUS"
SDCNT,	0			/STORAGE LOCATIONS
SDHIGH,	0
SDLOW,	0
SDHSUB,	0
SDLSUB,	0
SDBOX,	0
SDTEML,	0
SDGET,	0
SDPTR,	0

// Variables for DMUL
SIGNSW,	0
REST,	-2
MULTH,	0
MULTL,	0
MLTL,	0
MLTH,	0
MP3,	0
MP5,	0


// Variables for DIVIDE
DIVCNT,	0
DIVND1,	0
DIVND2,	0
DIVND3,	0
DIVND4,	0
HDIVSR,	0
LDIVSR,	0

M12,	-14			/ Constant -12(dec)
M13,	-15			/ Constant -13(dec)
M25,	-31			/ Constant -25(dec)
P127,	0177  			/ Constant
P3840,	7400  			/ Constant

DW1M,   364; 1100		/ Double Word constant 1000 000(dec)
DW100K,	30; 3240		/ Double Word constant 100 000(dec)
DW10K,	2; 3420			/ Double Word constant 10 000(dec)
DW1K,	0; 1750			/ Double Word constant 1000(dec)
DW100,	0; 144			/ Double Word constant 100(dec)
DW10,	0; 12			/ Double Word constant 10(dec)
DW1,	0; 1			/ Double Word constant 1(dec)

SDCONL,	
DWM1M,	7413; 6700		/ Double Word constant -100 0000(dec)
DWM100K,7747; 4540		/ Double Word constant -100 000(dec)
DWM10K,	7775; 4360		/ Double Word constant -10 000(dec)
DWM1K,	7777; 6030		/ Double Word constant -1 000(dec)
DWM100	7777; 7634		/ Double Word constant -100(dec)
DWM10,	7777; 7766		/ Double Word constant -10(dec)
DWM1,	7777; 7777		/ Double Word constant -1(dec)


OutInt,	OutInX
Prompt, PrompX
/]

*200
//					       ___    ____     ___     ___
//					      / _ \  |___ \   / _ \   / _ \
//					     | | | |   __) | | | | | | | | |
//					     | |_| |  / __/  | |_| | | |_| |
//					      \___/  |_____|  \___/   \___/

//                  _                    _
//  __/\__    ___  | |_    __ _   _ __  | |_
//  \    /   / __| | __|  / _` | | '__| | __|
//  /_  _\   \__ \ | |_  | (_| | | |    | |_
//    \/     |___/  \__|  \__,_| |_|     \__|
//
/[

        KCC     		/ Clear keyboard flag
	JMS 	TxtOut; Greet	/ Print greeting/header

//   ____                                       _
//  |  _ \   _ __    ___    _ __ ___    _ __   | |_
//  | |_) | | '__|  / _ \  | '_ ` _ \  | '_ \  | __|
//  |  __/  | |    | (_) | | | | | | | | |_) | | |_
//  |_|     |_|     \___/  |_| |_| |_| | .__/   \__|
//                                     |_|
//
PrompX,	CLA			/ Clear buffers
	TAD 	[-10-120]
	DCA 	cnt
	TAD 	[TokBuf-1]
	DCA 	iP1
	JMS 	ZeroM

	JMS 	TxtOut; Prmpt	/ Print Tiny Basic prompt
	JMS 	ReadLi		/ Collect one line of text from the user.
				/ ReadLi returns with the text in KBuf[]
				/ and the length of text in KBufL

	JMS 	TxtOut; CRLF

	JMS	Tokeni		/ Tokenize the string. It's hardcoded to
				/ use KBuf[] and KBufL as the source and
				/ TokBuf[] as destination

	/
	/ Check if this is a direct command or if it should be inserted
	/ into the code buffer. A direct command lacks the line number
	/ which then will have a zero value.
	/
	CLA	
	TAD 	(TokBuf-1)	/ Point to start of tokenized data
	DCA 	iP1
	TAD I 	iP1		/ Is LineNo High zero?
	SZA
	JMP	NotDir
	TAD I 	iP1		/ Is LineNo Low zero?
	SZA
	JMP 	NotDir
	/
	/ No line number given, so this is a driect command.
	/ Currently onlu RUN, LIST and NEW is accepted as
	/ direct commands
	/
	ISZ 	iP1		/ Skip the length
	TAD I 	iP1		/ Retrieve the command
	TAD	[40]
	SNA 	
	JMP	dcRUN
	IAC
	SNA
	JMP 	dcLST
	IAC
	SNA
	JMP 	dcNEW
	JMP 	Syntax

	/
	/ First search for the line in the code base and remove it if it's there
	/ already. Then check if the new line is not empty and insert it into
	/ the code base.
	/
NotDir,	JMS	FndLine		/ Locate line, return pointer in src
	SZL			/ L is 0 if exact line not found, so skip deleting
	JMS	CodDel		/ Delete line pointed to by src
	CLA			/ Now check if new line is empty
	TAD 	TokBuf+2	/  I.E length is 2
	TAD	[-2]
	SNA 			/ Skip if length is not 2
	JMP I	Prompt

	CLA			/ Now make a hole in the code
	TAD 	TokBuf+2	/ Add 2 to the length to fit LineNo
	TAD	[2]
	DCA	cnt
	TAD	src		/ The destination is 'cnt' away
	TAD	cnt
	DCA	dst
	JMS 	CodIns

	CLA			/ Then copy the new tokens into the code
	TAD 	TokBuf+2
	DCA	cnt
	TAD 	src
	DCA 	dst
	TAD 	(TokBuf)
	DCA	src
	JMS	CodCpy
	JMP I	Prompt

//
// Direct Command LIST
//
dcLST,	JMS	List
	JMP I	Prompt

//
// Direct Command NEW
//
dcNEW,	NL7777			/ Set first byte of code buffer to
	DCA I	[Code]		/ end-of-code marker 7777
	JMP I	Prompt

//
// Direct Command RUN
//
dcRUN,	
	JMP I	Prompt

/]



*400 
//					    
//					       ___    _  _      ___     ___
//					      / _ \  | || |    / _ \   / _ \
//					     | | | | | || |_  | | | | | | | |
//					     | |_| | |__   _| | |_| | | |_| |
//					      \___/     |_|    \___/   \___/

//    ____               _   ____           _
//   / ___|   ___     __| | |  _ \    ___  | |
//  | |      / _ \   / _` | | | | |  / _ \ | |
//  | |___  | (_) | | (_| | | |_| | |  __/ | |
//   \____|  \___/   \__,_| |____/   \___| |_|
//
/[
CodDel,	0
	CLA
	TAD	src		/ Get code line start
	TAD	[-1]		/ adjust for autoinc
	DCA	iP2		/ iP2 is autoincrementing destination
	TAD 	src
	IAC			/ Get length of line to delete
	IAC
	DCA 	tmp
	TAD I 	tmp
	TAD	src		/ Add the length to code line start 
	IAC			/ Adjust for LineNo and autoinc
	DCA	iP1		/ iP1 is autoincrementing source
CodDe0,	CLA
	TAD I 	iP1		/ Copy code data
	DCA I 	iP2
	TAD 	CODEND		/ Reached end of code?
	CIA
	TAD 	iP1
	SZA 
	JMP 	CodDe0
	JMP I 	CodDel
/]



//    ____               _   ___
//   / ___|   ___     __| | |_ _|  _ __    ___
//  | |      / _ \   / _` |  | |  | '_ \  / __|
//  | |___  | (_) | | (_| |  | |  | | | | \__ \
//   \____|  \___/   \__,_| |___| |_| |_| |___/
//
// Backwards copy 'cnt' bytes from 'src' to 'dst'
//
// Inputs: 	src, dst, cnt
// Modifies: 	src, dst, cnt, memory
// Outputs:
/[
CodIns,0
	CLA
	TAD	(1000)	/ TODO calculate length from end-of-code
	DCA	cnt


	TAD	cnt		/ Offset to last byte
	TAD 	src
	DCA 	src

	TAD	cnt		/ Offset to last byte
	TAD 	dst
	DCA 	dst

	TAD 	cnt		/ Make cnt negative for ISZ
	CIA
	DCA 	cnt

CodIn0,
	NLM1			/ src--
	TAD	src
	DCA 	src
	NLM1			/ dst--
	TAD	dst
	DCA 	dst
	TAD I	src		/ Move [src] -> [dst]
	DCA I 	dst
	ISZ	cnt		/ Loop until all 'cnt' bytes are moved
	JMP 	CodIn0
	JMP I	CodIns
/]


//    ____               _    ____
//   / ___|   ___     __| |  / ___|  _ __    _   _
//  | |      / _ \   / _` | | |     | '_ \  | | | |
//  | |___  | (_) | | (_| | | |___  | |_) | | |_| |
//   \____|  \___/   \__,_|  \____| | .__/   \__, |
//                                  |_|      |___/
/[
CodCpy,	0
	CLA
	TAD 	cnt
	IAC
	CMA
	DCA 	cnt
CodCp0,
	TAD I	src
	DCA I 	dst
	ISZ 	src
	ISZ 	dst
	ISZ 	cnt
	JMP 	CodCp0
	JMP I	CodCpy
/]



*600
//					       ___     __      ___     ___
//					      / _ \   / /_    / _ \   / _ \
//					     | | | | | '_ \  | | | | | | | |
//					     | |_| | | (_) | | |_| | | |_| |
//					      \___/   \___/   \___/   \___/



//   _____               _   _       _
//  |  ___|  _ __     __| | | |     (_)  _ __
//  | |_    | '_ \   / _` | | |     | | | '_ \
//  |  _|   | | | | | (_| | | |___  | | | | | |
//  |_|     |_| |_|  \__,_| |_____| |_| |_| |_|
//
// Find the starting address of the specified (or the next higher) line 
// number in the code area.
//
// Enter with desired line number in NumH/numL
// Returns with src pointing to the line. 
// L=1 if exact match, L=0 if the next higher is found
//
/[
FndLin,	0
	CLA
	TAD	[CODE]
	DCA	src

FndLi0,	CLA
	TAD	src;
	DCA	tmp
	TAD I 	tmp			/ Fetch Line No from code
	SPA				/ If LineNoH is not negative we not at end
	JMP 	FndLiL			/ Exit with src at end of code and L=0
	DCA	tmpH
	ISZ 	tmp
	TAD I 	tmp
	DCA	tmpL

	TAD 	[-6]			/ GREATER THAN OR EQUAL op for Compar
	JMS 	Compar; TmpH; NumH
	SZL 				/ Skip if no match
	JMP 	FndLiM

	ISZ 	src			/ Skip LineNoH
	ISZ 	src			/ Skip LineNoL
	CLA
	TAD	src			/ Get length			
	TAD I	src			/   and skip over the length as well
	DCA 	src
	JMP	FndLi0

/
/ Found a line that is either equal or larger than the desired line no
/ so compare Tmp and Num to see if they're equal and then return L=1, 
/ else return L=0
/
FndLiM,					
	CLA
	TAD 	TmpH
	CIA
	TAD 	NumH
	SZL
	JMP 	FndLiL
	CLA
	TAD 	TmpL
	CIA
	TAD 	NumL
	SZL
	JMP 	FndLiE

FndLiL,	CLL			/ Found larger, return with L=0
	JMP I 	FndLin		/ Exit with src pointing to start of line

FndLiE,	CLL CML			/ Found exact, return with L=1
	JMP I 	FndLin		/ Exit with src pointing to start of line

/]


*1000
//					      _    ___     ___     ___
//					     / |  / _ \   / _ \   / _ \
//					     | | | | | | | | | | | | | |
//					     | | | |_| | | |_| | | |_| |
//					     |_|  \___/   \___/   \___/



*1200
//					      _   ____     ___     ___
//					     / | |___ \   / _ \   / _ \
//					     | |   __) | | | | | | | | |
//					     | |  / __/  | |_| | | |_| |
//					     |_| |_____|  \___/   \___/



*1400
//					      _   _  _      ___     ___
//					     / | | || |    / _ \   / _ \
//					     | | | || |_  | | | | | | | |
//					     | | |__   _| | |_| | | |_| |
//					     |_|    |_|    \___/   \___/

//   _____          _                     _
//  |_   _|  ___   | | __   ___   _ __   (_)
//    | |   / _ \  | |/ /  / _ \ | '_ \  | |
//    | |  | (_) | |   <  |  __/ | | | | | |
//    |_|   \___/  |_|\_\  \___| |_| |_| |_|
//
// Tokenizes the NUL-terminated string in KBuf and stores the tokens 
// in TokBuf.
//
//
//
/[
Tokeni,	0
	CLA
	TAD	[KBuf]
	DCA	src
	TAD 	[TokBuf]
	DCA	dst
	
	JMS 	SkipSp		/ Skip spaces

	/
	/ Parse the line number and store it in the destination array
	/
	JMS	ATOL		/ Reads from src, stores in numH,numL

	CLA
	TAD	numH		/ Get high part of line number
	JMS	AppDst		/ Store in dst array
	TAD	numL		/ Get low part of line number
	JMS	AppDst		/ Store in dst array
	JMS 	AppDst		/ Clear the length

	/
	/ Start scanning for tokens
	/
TokenL,	/ TOKEN LOOP
	JMS 	SkipSp		/ Skip spaces
	CLA			/ Init iP1 to beginning of list of commands
	TAD	[CmdTxt-1]	
	DCA	iP1
	TAD	src		/ Save the start of possible token
	DCA	srcHld

	/
	/ Try matching the token with the command from the list
	/
Token1,	CLA
	TAD I 	iP1		/ Get character from command list
	SNA			/ Check if at end of command list (NULL)
	JMP	Token4		/   unknown command, go test is number or variable

	SPA			/ If command char is negative we have matched
	JMP 	TokenM		/   a full command.

	CMA			/ Now compare command char with token char
	IAC
	TAD I 	src		
	SZA			
	JMP	TokenF		/ No match of chars, go skip chars until the
				/   next command

	JMS 	IncSrc		/ Match, src++. go try the next pair 
	JMP	Token1		/   of characters

	/
	/ No match for current entry in command list, but it
	/ can also be that we reached the end of the token.
	/
TokenF,	CLA CLL			/ Check if src character is NULL
	TAD I 	src		
	SNA
	JMP 	TokenD		/ We're done, the entire line is processed
	CLA			/ Match fail, restore src so we can start matching
	TAD	srcHld		/  the current token from its beginning
	DCA	src
Token3,	CLA			/ Skip to next entry in the command list
	TAD I 	iP1
	SMA 			/ Check if end at command
	JMP 	Token3		/   not yet, loop some more characters
	JMP	Token1

	/
	/ It's not one of the standard defined tokens, so test it for a 
	/ variable A to Z
	/
Token4,	CLA CLL
	TAD I	src
	TAD 	[-101]		/ Subtract ASCII A
	SPA
	JMP	Token5		/ Not A..Z, go check if it's a number
	TAD 	[-31]		/ Check if character is <= than Z
	SMA
	JMP	Token5		/ Not A..Z, go check if it's a number
	CLA
	TAD 	[-1]		/ Token for variable is -1
	JMS 	AppDst
	TAD I 	SRC		/ Store variable name as is
	JMS 	AppDst
	JMS 	IncSrc		/ src++, Advance to next character
	JMP 	TokenL		/ Continue scanning for more tokens

	/
	/ Does the token start with a digit? Then assume it's a number
	/
Token5,	TAD	[-60]		/ subtract '0'
	SPA
	JMP  	Token6		/ Nope, not a digit
	TAD 	[-12]		/ Check if number is less than 10
	SMA
	JMP  	Token6		/ Nope, not a digit
	JMS	ATOL		/ Reads from src, stores in numH,numL, returns cnt used in AC
	TAD 	[-2]		/ Token for constant is -2
	JMS 	AppDst
	TAD 	numH		/ Store the number in dst array
	JMS 	AppDst
	TAD 	numL		/ Store the number in dst array
	JMS 	AppDst
	JMP 	TokenL		/ Continue scanning for more tokens

	/
	/ Can't parse it, so syntax error it is
	/
Token6,	JMP Syntax

	/
	/ We matched a token, so store it in the dst array
	/
TokenM,	/ TOKEN MATCH
	JMS	AppDst		/ Store in dst array
	JMP 	TokenL		/ Continue scanning for more tokens

	/
	/ Reached the end of the input string, so terminate
	/ the output with a NUL-token and return to calle
	/
TokenD,	/ TOKEN DONE
	CLA
	JMS	AppDst
	JMP I 	Tokeni

srcHld,	0	
/]



*1600
//					      _    __      ___     ___
//					     / |  / /_    / _ \   / _ \
//					     | | | '_ \  | | | | | | | |
//					     | | | (_) | | |_| | | |_| |
//					     |_|  \___/   \___/   \___/

//   _       _         _
//  | |     (_)  ___  | |_
//  | |     | | / __| | __|
//  | |___  | | \__ \ | |_
//  |_____| |_| |___/  \__|
//
/[
List,0
	CLA
	TAD	[CODE-1]
	DCA	iP1

ListL0,	CLA
	IAC
	TAD  	iP1		/ Print the line number
	DCA 	.+5
	TAD I	iP1		/ Check if linenumber is negative
	SPA			/  if so we reached end of code and
	JMP I	List		/  will return to caller
	JMS I	OutInt; 0
	ISZ	iP1		/ Skip over the low part of line number
	ISZ	iP1		/ Skip over the length

ListL1,	CLA			/ Process the tokens
	TAD I 	iP1		/ Get token and ajust since we want to find the end
				/   of the token before the correct token
	SNA			/ Is the 'token' 0000/EOL?
	JMP 	ListCR		/   yes, print CRLF

	IAC			
	SNA			/ Is it variable/7777?
	JMP 	ListVa		/  yes, go print the name of the variable

	IAC
	SNA			/ Is it constant/7776?
	JMP	ListCo		/  yes, go print the value of the constant

	IAC
	SNA			/ Is it "/7775?
	JMP	ListSt		/   yes, go print ASCII until next "
	TAD 	[-1]		/   no, undo the increment

	DCA	tmp		/ Store the token
	TAD	[CmdTxt-1]	/ Begin searching the command table for the token
	DCA	iP2

ListL2,	CLA
	TAD I 	iP2
	SNA
	HLT			/ Didn't find the token
	CMA
	TAD	tmp
	SZA
	JMP	ListL2		/ Continue scanning for token

	JMS 	SpcOut
	TAD 	iP2
	IAC
	DCA	.+2
	JMS 	TxtOut; 0
	JMP  	ListL1		/ Continue in current line

ListCR,	JMS 	TxtOut; CRLF
	JMP 	ListL0

ListVa,	JMS 	SpcOut
	TAD I 	iP1		/ 
	JMS 	ChrOut
	JMP  	ListL1		/ Continue in current line

ListCo,	JMS 	SpcOut
	TAD 	iP1
	IAC
	DCA	.+2
	JMS I	OutInt; 0
	ISZ 	iP1
	ISZ 	iP1
	JMP  	ListL1		/ Continue in current line

ListSt, JMS 	SpcOut
	TAD 	[42]
	JMS 	ChrOut
ListS0,	TAD I 	iP1
	TAD 	[3]
	SNA
	JMP 	ListS1
	TAD	[-3]
	JMS 	ChrOut
	JMP 	ListS0
ListS1, CLA
	TAD 	[42]
	JMS 	ChrOut
/	ISZ 	iP1
	JMP  	ListL1		/ Continue in current line
/]

*2000
//					      ____     ___     ___     ___
//					     |___ \   / _ \   / _ \   / _ \
//					       __) | | | | | | | | | | | | |
//					      / __/  | |_| | | |_| | | |_| |
//					     |_____|  \___/   \___/   \___/

//					    
//					    
//					      ____    ____     ___     ___
//					     |___ \  |___ \   / _ \   / _ \
//					       __) |   __) | | | | | | | | |
//					      / __/   / __/  | |_| | | |_| |
//					     |_____| |_____|  \___/   \___/
//					    
//					      ____    _  _      ___     ___
//					     |___ \  | || |    / _ \   / _ \
//					       __) | | || |_  | | | | | | | |
//					      / __/  |__   _| | |_| | | |_| |
//					     |_____|    |_|    \___/   \___/
//
//					      ____     __      ___     ___
//					     |___ \   / /_    / _ \   / _ \
//					       __) | | '_ \  | | | | | | | |
//					      / __/  | (_) | | |_| | | |_| |
//					     |_____|  \___/   \___/   \___/
//					    
//					      _____    ___     ___     ___
//					     |___ /   / _ \   / _ \   / _ \
//					       |_ \  | | | | | | | | | | | |
//					      ___) | | |_| | | |_| | | |_| |
//					     |____/   \___/   \___/   \___/
//					    
//					      _____   ____     ___     ___
//					     |___ /  |___ \   / _ \   / _ \
//					       |_ \    __) | | | | | | | | |
//					      ___) |  / __/  | |_| | | |_| |
//					     |____/  |_____|  \___/   \___/
//
//					      _____   _  _      ___     ___
//					     |___ /  | || |    / _ \   / _ \
//					       |_ \  | || |_  | | | | | | | |
//					      ___) | |__   _| | |_| | | |_| |
//					     |____/     |_|    \___/   \___/
//					    
//					      _____    __      ___     ___
//					     |___ /   / /_    / _ \   / _ \
//					       |_ \  | '_ \  | | | | | | | |
//					      ___) | | (_) | | |_| | | |_| |
//					     |____/   \___/   \___/   \___/
//					    
//					    
//					      _  _      ___     ___     ___
//					     | || |    / _ \   / _ \   / _ \
//					     | || |_  | | | | | | | | | | | |
//					     |__   _| | |_| | | |_| | | |_| |
//					        |_|    \___/   \___/   \___/
//
//					      _  _     ____     ___     ___
//					     | || |   |___ \   / _ \   / _ \
//					     | || |_    __) | | | | | | | | |
//					     |__   _|  / __/  | |_| | | |_| |
//					        |_|   |_____|  \___/   \___/
//					    
//					      _  _     _  _      ___     ___
//					     | || |   | || |    / _ \   / _ \
//					     | || |_  | || |_  | | | | | | | |
//					     |__   _| |__   _| | |_| | | |_| |
//					        |_|      |_|    \___/   \___/
//					    
//					      _  _      __      ___     ___
//					     | || |    / /_    / _ \   / _ \
//					     | || |_  | '_ \  | | | | | | | |
//					     |__   _| | (_) | | |_| | | |_| |
//					        |_|    \___/   \___/   \___/
//					    
//					    
//					    






*3000

//    ____
//   / ___|   ___    _ __ ___    _ __     __ _   _ __
//  | |      / _ \  | '_ ` _ \  | '_ \   / _` | | '__|
//  | |___  | (_) | | | | | | | | |_) | | (_| | | |
//   \____|  \___/  |_| |_| |_| | .__/   \__,_| |_|
//                              |_|
//
// Compares two 24-bit words pointed to by the arguments
//
// AC should be set to one of these numbers to select the
// type of comparison
//
//	-5   7773  =
//	-6   7772  >=
//	-7   7771  >
//	-10  7770  <>
//	-11  7767  <=
//	-12  7766  <
//
//	If comparison is false, return with L=0
//	If comparison is true, return with L=1
/[
Compar, 0
	DCA	Ctype

	TAD I	Compar          / Get address of param 1
	DCA	tmp
	TAD I 	tmp		/ Get high word of param1
	DCA 	Arg1H
	ISZ	tmp
	TAD I 	tmp		/ Get low word of param1
	DCA 	Arg1L
	ISZ 	Compar		/ Bump up return address

	TAD I	Compar          / Get address of param 2
	DCA	tmp
	TAD I 	tmp		/ Get high word of param2
	DCA 	Arg2H
	ISZ	tmp
	TAD I 	tmp		/ Get low word of param2
	DCA 	Arg2L
	ISZ 	Compar		/ Bump up return address

/SUBTRA,
        CLA CLL			/ not required if previous code always leaves AC==0
        TAD  	Arg2H+1
        CLL CMA CML IAC 	/ form 13-bit negative with no previous borrow
        TAD  	Arg1H+1		/ generates 0 for borrow, 1 for no borrow
        DCA  	ResH+1
        RAL			/ propagate "complemented" borrow
        TAD  	Arg2H		/ add previous stage borrow before forming negative
        CMA CML IAC		/ form 13-bit negative
        TAD  	Arg1H		/ generates 0 for borrow, 1 for no borrow
        DCA  	ResH

	CLA			/ After this ResH+1 is zero if both ResH
	TAD 	ResH		/ and ResH+1 was zero. And ResH can be tested
	CMA			/ for negative 
	DCA	tmp
	TAD 	ResH+1
	CMA
	AND 	tmp
	CMA
	DCA	ResH+1

	TAD	CTYPE		/ Calculate inexed jump based on CTYPE
	TAD 	[CompIx+12]
	DCA	tmp
	TAD I 	tmp
	DCA	tmp
	JMP I 	tmp
CompIx,	CompLT			/  <   LESS THAN
	CompLE			/  <=  LESS THAN OR EQUAL
	CompNE			/  <>  NOT EQUAL
	CompGT			/  >   GREATER THAN
	CompGE			/  >=  GREATER THAN OR EQUAL
	CompEQ			/  =   EQUAL

CompEQ,	CLA
	TAD 	ResH+1
	SNA			/ Skip if not equal
	JMP 	CompaT
	JMP 	CompaF

CompGE,	CLA
	TAD 	ResH+1
	SNA			/ Skip if not equal
	JMP 	CompaT

CompGT,	/ Begin by testing if Arg1 is negative and Arg2 is positive
	/ if it is so then Arg1 can't be larger than Arg2 so we fail
	CLA
	TAD 	Arg1H
	SMA 			/ Skip if minus acc
	JMP 	CompL1
	CLA
	TAD	Arg2H
	SMA 			/ Skip if minus acc
	JMP 	CompaF

CompL1,	/  Then testing if Arg1 is positive and Arg2 is negative
	/ if it is so then Arg1 must be larger than Arg2 so we succeed
	CLA
	TAD 	Arg1H
	SPA 			/ Skip if positive acc
	JMP 	CompL2
	CLA
	TAD	Arg2H
	SPA 			/ Skip if positive acc
	JMP 	CompaT

CompL2,	/ Fall back on regular subtraction testing since we ruled out
	/ the cases where an overflow can cause incorrect
	CLA
	TAD 	ResH
	SPA 			/ Skip if minus
	JMP 	CompaF
	CLA
	TAD	ResH+1
	SZA
	JMP 	CompaT
	JMP 	CompaF


CompNE,	CLA
	TAD 	ResH+1
	SZA
	JMP 	CompaT
	JMP 	CompaF

CompLE,	CLA
	TAD 	ResH+1
	SNA			/ Skip if not equal
	JMP 	CompaT


CompLT,	/ Begin by testing if Arg1 is positive and Arg2 is negative
	/ if it is so then Arg1 can't be smaller than Arg2 so we fail
	CLA
	TAD 	Arg1H
	SPA 	 		/ Skip if plus acc
	JMP 	CompL3
	CLA
	TAD	Arg2H
	SPA 	 		/ Skip if plus acc
	JMP 	CompaF

CompL3,	/  Then testing if Arg1 is negative and Arg2 is positive
	/ if it is so then Arg1 must be smaller than Arg2 so we succeed
	CLA
	TAD 	Arg1H
	SMA			/ Skip if negative acc
	JMP 	CompL4
	CLA
	TAD	Arg2H
	SMA 			/ Skip if negtive acc
	JMP 	CompaT

CompL4,	/ Fall back on regular subtraction testing since we ruled out
	/ the cases where an overflow can cause incorrect
	CLA
	TAD 	ResH
	SPA 			/ Skip if plus
	JMP 	CompaT
	JMP 	CompaF

CompaF,	CLL			/ Comparison false, return with L=0
	JMP I 	Compar

CompaT,	CLL CML			/ Comparison true, return with L=1
	JMP I 	Compar


/]


*2200




*5000
//					      ____     ___     ___     ___
//					     | ___|   / _ \   / _ \   / _ \
//					     |___ \  | | | | | | | | | | | |
//					      ___) | | |_| | | |_| | | |_| |
//					     |____/   \___/   \___/   \___/


//    ___            _     ___           _
//   / _ \   _   _  | |_  |_ _|  _ __   | |_
//  | | | | | | | | | __|  | |  | '_ \  | __|
//  | |_| | | |_| | | |_   | |  | | | | | |_
//   \___/   \__,_|  \__| |___| |_| |_|  \__|
//
// SIGNED DECIMAL PRINT, DOUBLE PRECISION
// CALLING SEQUENCE:  JMS OutInt /SUBROUTINE CALLED
//                    HIADDR     /ADDRESS OF HIGH ORDER WORD
//                    RETURN     /RETURN WITH AC AND L CLEAR
/[
OutInX,	0
	CLA CLL
	TAD I 	OutInX		/PICK UP ADDRESS OF HIGH-ORDER WORD
	DCA 	SDGET
	TAD I 	SDGET		/PICK UP HIGH-ORER WORD
	SMA CLA			/IS IT NEGATIVE?
	TAD 	SDPLUS		/NO, GENERATE CODE FOR SPACE
	TAD 	SDMNS		/YES, GENERATE CODE FOR "MINUS"
	JMS 	DigOut		/TYPE IT OUT
	TAD I 	SDGET		/PICK UP HIGH-ORDER WORD AGAIN
	SPA			/IS IT POSITIVE?
	CMA CML			/NO, COMPLEMENT IT. SET LINK
	DCA 	SDHIGH		/STORE POSITIVE WORD FOR USE IN SUBROUTINE
	ISZ 	SDGET
	TAD I 	SDGET		/PICK UP LOW-ORDER WORD
	SZL			/IS LINK SET?
	CMA CLL IAC		/YES, FORM TWO'S COMPLEMENT
	SZL			/DID AC OVERFLOW FROM "IAC"?
	ISZ 	SDHIGH		/YES, CORRECT HIGH-ORDER WORD
	DCA 	SDLOW		/STORE POSITIVE LOW-ORDER WORD
	TAD 	SDLOOP		/INITIALIZE DIGIT COUNTER TO "7"
	DCA 	SDCNT
	TAD 	[DWM1M]		/INITIALIZE POINTER TO TABLE OF POWERS OF TEN
	DCA 	SDPTR
	ISZ 	OutInX		/INDEX LINKAGE FOR CORRECT RETURN
SDARND,	TAD I	SDPTR		/PICK UP POWER OF TEN FOR USE IN SUBTRACT
	ISZ 	SDPTR
	DCA 	SDHSUB
	TAD I 	SDPTR
	ISZ 	SDPTR
	DCA 	SDLSUB
SDDO,	CLL			/DOUBLE PRECISION SUBTRACTION
	TAD	SDLSUB
	TAD	SDLOW
	DCA	SDTEML
	RAL
	TAD	SDHSUB
	TAD	SDHIGH
	SPA			/DID IT UNDERFLOW?
	JMP	SDOUT		/NO, COUNT IS DONE
	ISZ	SDBOX		/YES, COUNT NOT DONE. INDEX DIGIT
	DCA	SDHIGH		/DEPOSIT REMAINING HIGH-ORDER PORTION
	TAD	SDTEML		/RESTORE REMAINING LOW-ORDER PORTION
	DCA	SDLOW
	JMP	SDDO		/GO BACK AND SUBTRACT AGAIN
SDOUT, 	CLA
	TAD	SDBOX		/PICK UP RESULTING DIGIT
	JMS	DigOut		/TYPE IT OUT
	DCA	SDBOX		/INITIALIZE DIGIT TO "0"
	ISZ	SDCNT		/HAVE WE TYPED "7" DIGITS
	JMP	SDARND		/NO, DETERMINE NEXT DIGIT
	JMP I	OutInX		/YES, SUBROUTINE DONE. RETURN
/]


//   ____                       _   _       _
//  |  _ \    ___    __ _    __| | | |     (_)
//  | |_) |  / _ \  / _` |  / _` | | |     | |
//  |  _ <  |  __/ | (_| | | (_| | | |___  | |
//  |_| \_\  \___|  \__,_|  \__,_| |_____| |_|
//
// Read a line from the TTY with editing
// The string is stored in KBuf and the length of the string
// is stored in KBufL
//
/[
ReadLi,	0
	CLA			/ Initialize keyboard buffer
	DCA	KBufL		/ Set length of string to zero
	TAD	[KBuf-1]	/ Point to beginning of keyboard buffer
	DCA	KBufP

ReadL0,
	JMS	GetKey

	/ Test key for BACKSPACE  10   8(dec)	delta 10
	/              LINEFEED   12  10(dec)	delta 2
	/              ENTER      15  13(dec)	delta 3
	/              DELETE    177 127(dec)	delta 162

	TAD	[-10]		/ Subtract BACKSPACE
	SNA			/ Test if it was BACKSPACE
	JMP	BACKSP

	TAD	[-2]		/ Subtract delta to LINEFEED
	SNA			/ Test if it was LINEFEED
	JMP	ReadL0		/ If so, ignore the key

	TAD	[-3]		/ Subtract delta to ENTER
	SNA			/ Test if it was ENTER
	JMP I 	ReadLi		/ If so, then return back to caller

	TAD	[-162]		/ Subtract delta to DELETE
	SNA			/ Test if it was DELETE
	JMP	BACKSP		/ If so, then handle as a BACKSPACE

	CLA CLL			/ Reload the key value
	TAD 	Key
	TAD	[-40]		/ Is it a valid printable character i.e.
	SPA			/ greater or equal to SPACE
	JMP 	KeyERR

	CLA CLL			/ Check if keyboard buffer full
	TAD	KBufL 		/ Length of string in keyboard buffer
	TAD	[-120]		/ 80(dec)
	SMA
	JMP	KeyERR
	ISZ	KBufL

	CLA CLL			/ Reload the key value
	TAD 	Key
	TLS			/ Print the key
	DCA I 	KBufP		/ Store the key into the buffer
	JMP 	ReadL0

KeyERR,
	CLA			/ Print the BEL character to alert for error
	TAD 	[7]
	TLS
	JMP	ReadL0


BACKSP,	CLA			/ Check if buffer is not empty
	TAD	KBufL	
	SNA
	JMP 	ReadL0		/ It's empty, ignore backspace 
	TAD	[-1]		/ Decrement string length	
	DCA	KBufL
	TAD 	KBufP		/ Decrement string pointer
	TAD	[-1]
	DCA	KBufP
	CLA			/ Print the backspace/erase sequence	
	JMS 	TxtOut; BsSpBs
	JMP 	ReadL0
/]

*5200
//					      ____    ____     ___     ___
//					     | ___|  |___ \   / _ \   / _ \
//					     |___ \    __) | | | | | | | | |
//					      ___) |  / __/  | |_| | | |_| |
//					     |____/  |_____|  \___/   \___/

//      _          _       _
//     / \      __| |   __| |
//    / _ \    / _` |  / _` |
//   / ___ \  | (_| | | (_| |
//  /_/   \_\  \__,_|  \__,_|
//
//  Adds 24 bits Arg1 and Arg2 into 24 bit Res
//
//  Returns AC=0 
//          L=1 if overflow
/[
Add,	0
	CLA CLL 
	TAD 	Arg1H+1
	TAD 	Arg2H+1 
	DCA 	ResH+1
	RAL 
	TAD 	Arg1H; 
	TAD 	Arg2H; 
	DCA 	ResH
	JMP I 	Add
/]


//   ____            _
//  / ___|   _   _  | |__
//  \___ \  | | | | | '_ \
//   ___) | | |_| | | |_) |
//  |____/   \__,_| |_.__/
//
//  Subtracts 24 bits Arg1 from Arg2 into 24 bit Res
//
//  Returns AC=0 
//          L=0 if underflow 
/[
Sub,	0
        CLA CLL			/ not required if previous code always leaves AC==0
        TAD  	Arg2H+1
        CLL CMA CML IAC 	/ form 13-bit negative with no previous borrow
        TAD  	Arg1H+1		/ generates 0 for borrow, 1 for no borrow
        DCA  	ResH+1
        RAL			/ propagate "complemented" borrow
        TAD  	Arg2H		/ add previous stage borrow before forming negative
        CMA CML IAC		/ form 13-bit negative
        TAD  	Arg1H		/ generates 0 for borrow, 1 for no borrow
        DCA  	ResH
	JMP I	Sub
/]
//   ____    ___  __     __  ___   ____    _____
//  |  _ \  |_ _| \ \   / / |_ _| |  _ \  | ____|
//  | | | |  | |   \ \ / /   | |  | | | | |  _|
//  | |_| |  | |    \ V /    | |  | |_| | | |___
//  |____/  |___|    \_/    |___| |____/  |_____|
//
// BASED ON DEC-08-FMEA-LA 
// DOUBLE PRECISION DIVIDE SUBROUTINE,
// Stipped down from 48 bit Dividend to 24 bit
//
// CALLING SEQUENCE:
//         JMS DIVIDE
//	    ADDRESS OF HIGH ORDER DIVIDEND
//          ADDRESS OF HIGH ORDER DIVISOR
//
//         RETURN: DIVND3/AC = HIGH ORDER QUOTIENT
//                 DIVND4 = LOW ORDER QUOTIENT
//                 DIVND1 = HIGH ORDER REMAINDER
//                 DIVND2 = LOW ORDER REMAINDER
//
// IF DIVISOR<DIVIDEND; RESULTS UNSPECIFIED
//
/[
Divide,	0
	CLA
	DCA	DIVND1
	DCA	DIVND2

	TAD I	DIVIDE		/ Get Dividend address from parameters
	DCA	ADDRS
	ISZ	DIVIDE		/ Adjust return address

	TAD I	ADDRS		/ Dividend High
	DCA	DIVND3
	ISZ	ADDRS
	TAD I	ADDRS		/ Dividend Low
	DCA	DIVND4

	TAD I	DIVIDE		/ Get Divisor address from parameters
	DCA	ADDRS
	ISZ	DIVIDE		/ Adjust return address

	TAD I	ADDRS		/ Divisor High
	DCA	HDIVSR
	ISZ	ADDRS
	TAD I	ADDRS		/ Divisor Low
	DCA	LDIVSR
	
	TAD	M25			/ SETUP FOR 24 LOOPS
	DCA	DIVCNT		/ SET DIVIDE COUNT=24
	CLL
	JMP	DIV2

DIV3,	TAD	DIVND2		/ SHIFT HIGH DIVIDEND
	RAL			/ LEFT
	DCA	DIVND2
	TAD	DIVND1
	RAL
	DCA	DIVND1
	TAD	DIVND2		/ COMPARE DIVISOR;
	TAD	LDIVSR		/ WITH DIVISOR
	DCA	ADDRS
	RAL			/ GET CARRY
	TAD	DIVND1
	TAD	HDIVSR
	SNL
	JMP	DIV2-1
	DCA	DIVND1
	TAD	ADDRS
	DCA	DIVND2
	CLA
DIV2,	TAD	DIVND4		/ ROTATE LOW ORDER
	RAL			/ WORDS LEFT
	DCA	DIVND4
	TAD	DIVND3		/Q UTOIENT BITS
	RAL
	DCA	DIVND3		/ ENTER FROM C(L)
	ISZ	DIVCNT		/ DONE 24?
	JMP	DIV3		/ NO: CONTINUE
	JMP I	DIVIDE		/ We're done, exit subroutine

/]


//   _   _                          _
//  | \ | |   ___    __ _    __ _  | |_    ___
//  |  \| |  / _ \  / _` |  / _` | | __|  / _ \
//  | |\  | |  __/ | (_| | | (_| | | |_  |  __/
//  |_| \_|  \___|  \__, |  \__,_|  \__|  \___|
//                  |___/
// Negate the 24 bit value pointed to by the parameter
// Returns the value in tmpH/tmpL
/[
Negate,	0
	CLA CLL
	TAD I	Negate          / Get address of parameter
	DCA	tmpH
	TAD 	tmpH
	IAC
	DCA	tmpL
	ISZ	Negate		/ Bump up return address

	TAD I	tmpL 
	CMA
	DCA I 	tmpL
	TAD I	tmpH
	CMA
	DCA I 	tmpH

	TAD I	tmpL 
	TAD 	[1] 
	DCA I 	tmpL
	RAL
	TAD I	tmpH
	DCA I 	tmpH

	JMP I	Negate
/]

//      _      _____    ___    _
//     / \    |_   _|  / _ \  | |
//    / _ \     | |   | | | | | |
//   / ___ \    | |   | |_| | | |___
//  /_/   \_\   |_|    \___/  |_____|
//
// Converts ascii text into a double word int ends at first non-digit.
// Reads from src, stores in numH,numL, returns cnt used in AC
//
/[ 
ATOL,	
	0
	CLA
	DCA	numH		/ Clear the multiplicator
	DCA 	numL

ATOL0,	TAD I 	src		/ Get character

	TAD	[-60]		/ subtract '0'
	DCA	tmp		/ save it as number 0 .. 9+
	TAD 	tmp		/ reload
	SPA
	JMP I 	ATOL		/ Done
	TAD 	[-12]		/ Check if number is less than 10
	SMA
	JMP I 	ATOL		/ Done

	CLA			/ We found a valid digit
	ISZ 	src		/ Tncrement the source address

	JMS	Multip		/ Multiply the summing up variable by 10
		    numH
		    DW10	

	CLA CLL			/ Copy result back to the summing up variable
	TAD	D
	DCA 	numL
	TAD	C
	DCA 	numH

	TAD	tmp		/ Add our number to the summing up variable
	TAD 	numL
	DCA 	numL
	RAL
	TAD 	numH
	DCA 	numH
	JMP 	ATOL0

/]


*5400
//					      ____    _  _      ___     ___
//					     | ___|  | || |    / _ \   / _ \
//					     |___ \  | || |_  | | | | | | | |
//					      ___) | |__   _| | |_| | | |_| |
//					     |____/     |_|    \___/   \___/
//					    

/]
//   __  __           _   _     _
//  |  \/  |  _   _  | | | |_  (_)  _ __
//  | |\/| | | | | | | | | __| | | | '_ \
//  | |  | | | |_| | | | | |_  | | | |_) |
//  |_|  |_|  \__,_| |_|  \__| |_| | .__/
//                                 |_|//
// DIGITAL-8-13-F
// SIGNED DOUBLE PRECISION MULTIPLY ROUTINE
// CALLING SEQUENCE:
//        JMS DMUL
//        ADDRESS OF MULTIPLICAND(HIGH ORDER)
//        ADDRESS OF MULTIPLIER(HIGH ORDER)
//        RETURN HIGH TO LOW IN A,B,C,D
/[
Multip,	0
	CLL CLA
	TAD	REST		/-2
	DCA	SIGNSW		/SET SIGN SWITCH
	JMS	TSIGN		/FETCH AND SET SIGN
	TAD	MLTH		/RESULT IN MLTH,MLTL
	DCA	MULTH		/HIGH ORDER MULTIPLICAND
	TAD	MLTL
	DCA	MULTL		/LOW ORDER MULTIPLICAND
	JMS	TSIGN		/FETCH AND SET SIGN
	TAD	MULTL		/LOW ORDER MULTIPLICAND
	DCA	MiDst
	TAD	MLTL		/LOW ORDER MULTIPLIER
	JMS	MP4		/MULTIPLY
	DCA	D		/LOW ORDER
	TAD	MP5
	DCA	C		/HIGH ORDER
	TAD	MULTH		/HIGH ORDER MULTIPLICAND
	DCA	MiDst
	TAD	MLTL		/LOW ORDER MULTIPLIER
	JMS	MP4		/MULTIPLY
	TAD	C
	DCA	C
	RAL			/GET CARRY
	TAD	MP5
	DCA	B
	RAL			/GET CARRY
	DCA	A
	TAD	MULTL		/LOW ORDER MULTIPLICAND
	DCA	MiDst
	TAD	MLTH		/HIGH ORDER MULTIPLIER
	JMS	MP4		/MULTIPLY
	TAD	C
	DCA	C		/ADD
	RAL			/GET CARRY
	TAD	MP5
	TAD	B
	DCA	B
	RAL			/GET CARRY
	TAD	A
	DCA	A		/ADD
	TAD	MULTH		/HIGH ORDER MULTIPLICAND
	DCA	MiDst
	TAD	MLTH		/HIGH ORDER MULTIPLIER
	JMS	MP4
	TAD	B
	DCA	B
	RAL
	TAD	MP5
	TAD	A
	ISZ	SIGNSW		/ANSWER <0??
	JMP I	Multip		/NO: EXIT
	DCA	A		/YES
	TAD	D
	CMA CLL IAC		/NEGATE
	DCA	D
	TAD	C		/NEGATE
	JMS	COM
	DCA	C
	TAD	B
	JMS	COM		/NEGATE
	DCA	B
	TAD	A
	JMS	COM
	DCA	A		/ Added by MEM
	JMP I	Multip		/EXIT

MiDst,
COM,	0
	CMA
	SZL
	CLL IAC
	JMP I	COM

MiSrc,
TSIGN,	0
	TAD I	Multip		/FETCH ADDRESS
	DCA	ADDRS
	TAD I	ADDRS		/FETCH HIGH ORDER
	CLL
	SPA			/IS IT <0?
	CMA CML			/YES: COMPLEMENT, SET LINK
	DCA	MLTH
	ISZ	ADDRS
	TAD I	ADDRS		/FETCH LOW ORDER
	SZL			/WAS IT <0?
	ISZ	SIGNSW		/YES, ADD 1 TO SWITCH
	NOP
	SZL
	CMA CLL IAC		/COMPLEMENT, CLEAR LINK
	DCA	MLTL
	SZL			/CARRY?
	ISZ	MLTH		/YES
	ISZ	Multip
	JMP I 	TSIGN		/EXIT ROUTINE

MP4,	0		/UNSIGNED MULTIPLY
	DCA	MiSrc
	DCA	MP5
	TAD	M12		/COUNT 12 BITS
	DCA	MP3
	CLL
	TAD	MiSrc		/CARRY GOES INTO
	RAR			/LEFT OF MiSrc
	DCA	MiSrc		/TEST MULTIPLIER BIT
	TAD	MP5
	SNL			/A 1?
	JMP	.+3		/NO: DON'T ADD
	CLL			/YES: ADD
	TAD	MiDst
	RAR
	DCA	MP5
	ISZ	MP3		/DONE 12 BITS?
	JMP	MP4+6		/NO: CARRY IS IN C(L)
	TAD	MiSrc		/YES: DONE
	RAR
	CLL
	JMP I	MP4		/EXIT
/]

*5600
//					      ____     __      ___     ___
//					     | ___|   / /_    / _ \   / _ \
//					     |___ \  | '_ \  | | | | | | | |
//					      ___) | | (_) | | |_| | | |_| |
//					     |____/   \___/   \___/   \___/
//					    

//   ____                        _
//  |  _ \    __ _   _ __     __| |   ___    _ __ ___
//  | |_) |  / _` | | '_ \   / _` |  / _ \  | '_ ` _ \
//  |  _ <  | (_| | | | | | | (_| | | (_) | | | | | | |
//  |_| \_\  \__,_| |_| |_|  \__,_|  \___/  |_| |_| |_|
//
// DECUS 5-25  RANDOM NUMBER GENERATOR
// Returns 12 bit random number in AC and rndval
// Destroys tmp1,tmp2,tmp3
// 
/[
Random,	0
	CLA
	TAD	rseed1
	RAL
	AND	P3840	
	DCA	tmp3	
	TAD	rseed2	
	AND	P127	
	TAD	tmp3	
	RTL
	RTL
	RAL
	DCA	tmp1	
	TAD	rseed1	
	AND	P127
	RTL
	RTL
	RAL
	TAD	rseed2	
	DCA	tmp2	
	SZL
	ISZ	tmp1	
	NOP
	TAD	rseed1
	CLL	RAL	
	SZL
	ISZ	tmp2
	SKP
	ISZ	tmp1	
	NOP
	CLL
	TAD	rseed1	
	DCA	rseed1
	TAD	rseed2	
	RAL
	SZL
	ISZ	tmp1	
	NOP
	CLL
	TAD	tmp2	
	DCA	rseed2	
	TAD	rseed3	
	RAL
	TAD	rseed3	
	TAD	tmp1	
	DCA	rseed3	
	TAD	rseed3	
	JMP	I RANDOM

rseed3,;rndval,	0000  		/ 36bit random(seed) word High part
rseed2,		0000  		/ 36bit random(seed) word Middle part
rseed1,		0001  		/ 36bit random(seed) word Low part
/]




*6000
//					       __      ___     ___     ___
//					      / /_    / _ \   / _ \   / _ \
//					     | '_ \  | | | | | | | | | | | |
//					     | (_) | | |_| | | |_| | | |_| |
//					      \___/   \___/   \___/   \___/
//					    

//                             _            _                __
//  __/\__   ___    ___     __| |   ___    | |__    _   _   / _|
//  \    /  / __|  / _ \   / _` |  / _ \   | '_ \  | | | | | |_
//  /_  _\ | (__  | (_) | | (_| | |  __/   | |_) | | |_| | |  _|
//    \/    \___|  \___/   \__,_|  \___|   |_.__/   \__,_| |_|
////
//
// Data structure of the P-code
//      <-- 100 -->   <nxt>  PRINT  'var'  A      :      PRINT  'var'  B     'eol'
//	0000   0144   0011   7756   7777   0101   7775   7756   7777   0102   0000
//      LineHi LineLo Skip  <---------------------  opcodes  -------------------->
//
/[
CODE,

	0001; 1610; 0006; 7775; 0111; 0111; 7775; 0
	0002; 3420; 0006; 7775; 0122; 0122; 7775; 0
	0003; 5230; 0006; 7775; 0133; 0133; 7775; 0
	0004; 7040; 0006; 7775; 0144; 0144; 7775; 0


/CODE0,	0000; 0001; 0006; 7754; 7740; 7753; 7741; 0							/   1 IF RUN THEN END ???
/CODE1,	0000; 0144; 0011; 7756; 7777; 0101; 7774; 7756; 7777; 0102; 0					/ 100 PRINT A:PRINT B
/CODE2,	0000; 0310; 0010; 7757; 7777; 0101; 7773; 7777; 0102; 0						/ 200 LET A=B
/CODE3,	0000; 0454; 0016; 7754; 7777; 0101; 7773; 7777; 0102; 7753; 7777; 0103; 7773; 7777; 0104; 0	/ 300 IF A=B THEN C=D
/CODE4,  0000; 0620; 0014; 7757; 7777; 0101; 7773; 7777; 0101; 7765; 7776; 0036; 1100; 0			/ 400 LET A = A + 123456
/CODE5,  0000; 0764; 0010;  7756; 7775; 0101; 0102; 0103; 7775; 0					/ 500 PRINT "ABC"

	7777

//					       __     ____     ___     ___
//					      / /_   |___ \   / _ \   / _ \
//					     | '_ \    __) | | | | | | | | |
//					     | (_) |  / __/  | |_| | | |_| |
//					      \___/  |_____|  \___/   \___/
//					    

//					       __     _  _      ___     ___
//					      / /_   | || |    / _ \   / _ \
//					     | '_ \  | || |_  | | | | | | | |
//					     | (_) | |__   _| | |_| | | |_| |
//					      \___/     |_|    \___/   \___/
//					    

//					       __      __      ___     ___
//					      / /_    / /_    / _ \   / _ \
//					     | '_ \  | '_ \  | | | | | | | |
//					     | (_) | | (_) | | |_| | | |_| |
//					      \___/   \___/   \___/   \___/
//					    					    

//					      _____    ___     ___     ___
//					     |___  |  / _ \   / _ \   / _ \
//					        / /  | | | | | | | | | | | |
//					       / /   | |_| | | |_| | | |_| |
//					      /_/     \___/   \___/   \___/
//					    

*7170
CODEND,	.
/]

*7200
//					      _____   ____     ___     ___
//					     |___  | |___ \   / _ \   / _ \
//					        / /    __) | | | | | | | | |
//					       / /    / __/  | |_| | | |_| |
//					      /_/    |_____|  \___/   \___/
//					    
//                                   _                __
//  __/\__ __   __   __ _   _ __    | |__    _   _   / _|
//  \    / \ \ / /  / _` | | '__|   | '_ \  | | | | | |_
//  /_  _\  \ V /  | (_| | | |      | |_) | | |_| | |  _|
//    \/     \_/    \__,_| |_|      |_.__/   \__,_| |_|
//
/[
VARBUF,	
TokBuf,	ZBLOCK 	10		/ Used for a bit of extra space when tokenizing 
				/ the key input buffer. The length of the 
				/ tokenized string can be longer than the raw
				/ string if there's a lot of 1 ot 2 digit
				/ constants in the line.

KBuf,	ZBLOCK	120		/ Keyboard input buffer 80(dec) bytes

AZvars,	ZBLOCK 	64		/ The A-Z variables 26*2(dec) bytes
/]


//                                         _                     _
//  __/\__     ___    ___    _ __    ___  | |_    __ _   _ __   | |_   ___
//  \    /    / __|  / _ \  | '_ \  / __| | __|  / _` | | '_ \  | __| / __|
//  /_  _\   | (__  | (_) | | | | | \__ \ | |_  | (_| | | | | | | |_  \__ \
//    \/      \___|  \___/  |_| |_| |___/  \__|  \__,_| |_| |_|  \__| |___/
//
/[
CONSTS,

Greet,	15; 12; "T; "B; "8; " ; "v; "0; ".; "0; "1; 
CRLF,	15; 12; 0
Prmpt,	15; 12; ">; 0
SynErr,	15; 12; "S; "Y; "N; "T; "A; "X; 15; 12; 0
BsSpBs,	10; 40; 10; 0

CmdTxt,
	1;				-1	/ 7777  Variable token
	2;				-2	/ 7776  Constant token
	42;				-3	/ 7775  "
	72;				-4	/ 7774  :
	75;				-5	/ 7773  =
	76;75;				-6	/ 7772  >=
	76;				-7	/ 7771  >
	74;76;				-10	/ 7770  <>
	74;75;				-11	/ 7767  <=
	74;				-12	/ 7766  <
	53;				-13	/ 7765  +
	55;				-14	/ 7764  -
	52;				-15	/ 7763  *
	57;				-16	/ 7762  /
	50;				-17	/ 7761  (
	51;				-20	/ 7760  )
	114;105;124;			-21	/ 7757  LET
	120;122;111;116;124;		-22	/ 7756  PRINT
	77;				-23	/ 7755  ?
	111;106;			-24	/ 7754  IF
	124;110;105;116;		-25	/ 7753  THEN 
	105;114;123;105;		-26	/ 7752  ELSE
	107;117;124;117;		-27	/ 7751  GOTO
	107;117;123;125;102;		-30	/ 7750  GOSUB
	122;105;124;125;122;116;	-31	/ 7747  RETURN
	106;117;122;			-32	/ 7746  FOR
	124;117;			-33 	/ 7745  TO
	123;124;105;120;		-34	/ 7744  STEP
	116;105;130;124;		-35 	/ 7743  NEXT
	122;116;104;			-36	/ 7742  RND
	105;116;104;			-37	/ 7741  END 
	122;125;116;			-40	/ 7740  RUN
	114;111;123;124;		-41	/ 7737  LIST
	116;105;127;			-42	/ 7736  NEW
	0
/]


//   ____                    ___            _
//  / ___|   _ __     ___   / _ \   _   _  | |_
//  \___ \  | '_ \   / __| | | | | | | | | | __|
//   ___) | | |_) | | (__  | |_| | | |_| | | |_
//  |____/  | .__/   \___|  \___/   \__,_|  \__|
//          |_|
/[
SpcOut,	0
	CLA
	TAD 	[40]
	JMS 	ChrOut
	JMP I	SpcOut
/]


//   _____          _      ___            _
//  |_   _| __  __ | |_   / _ \   _   _  | |_
//    | |   \ \/ / | __| | | | | | | | | | __|
//    | |    >  <  | |_  | |_| | | |_| | | |_
//    |_|   /_/\_\  \__|  \___/   \__,_|  \__|
//
// Print the text pointed to by the parameter. Calls ChrOut 
// for the actual outputting. Returns with AC and L cleared.
//
// Inputs: 	parameter
// Modifies: 	AC PrintP
// Outputs:
//
/[
TxtOut,	0
	CLA CLL
	TAD I	TxtOut          / Get address of parameter
	TAD	[-1]
	DCA	PrintP
	ISZ 	TxtOut		/ Bump up return address

TxtOu,
	CLA			/ Get character to print
	TAD I 	PrintP		
	SPA SNA			/ Return to caller if at end of message
	JMP I 	TxtOut		 
	JMS 	ChrOut		/ Call the character out for printing
	JMP 	TxtOu		/ Now do next character
/]

//   ____    _            ___            _
//  |  _ \  (_)   __ _   / _ \   _   _  | |_
//  | | | | | |  / _` | | | | | | | | | | __|
//  | |_| | | | | (_| | | |_| | | |_| | | |_
//  |____/  |_|  \__, |  \___/   \__,_|  \__|
//               |___/
//
// Outputs a number ranging between 0 and 9(dec) as a ASCII 
// character to the TTY.  Calls ChrOut for the actual outputting.
// Returns with AC and L cleared
//
// Inputs: 	AC
// Modifies: 	AC,L
// Outputs:
//
/[
DigOut,	0
	TAD	[60]		/ Convert number 0..9 to ASCII 0..9
	JMS	ChrOut		/ Call the ASCII printing function
	JMP I 	DigOut
/]


//    ____   _               ___            _
//   / ___| | |__    _ __   / _ \   _   _  | |_
//  | |     | '_ \  | '__| | | | | | | | | | __|
//  | |___  | | | | | |    | |_| | | |_| | | |_
//   \____| |_| |_| |_|     \___/   \__,_|  \__|
//
// Output the data in AC to the TTY and wait for the TTY
// to become ready again. Clears AC and L before returning
//
// Inputs: 	AC
// Modifies: 	AC,L
// Outputs:
//
/[
ChrOut,	0 
	TLS		/ Send to TTY
	TSF		/ Wait for TTY to become ready
	JMP	.-1
	CLA CLL		/ Clear AC and L
	JMP I	ChrOut
/]


//     ____          _     _  __
//    / ___|   ___  | |_  | |/ /   ___   _   _
//   | |  _   / _ \ | __| | ' /   / _ \ | | | |
//   | |_| | |  __/ | |_  | . \  |  __/ | |_| |
//    \____|  \___|  \__| |_|\_\  \___|  \__, |
//                                       |___/
//
// Wait for a character to arrive from the TTY, mask off the parity, store it in 'Key'
// and also return it in AC
//
// Inputs: 
// Modifies: 	AC
// Outputs:	Key
//
/[
GetKey,	0
	KSF     		/ Spin here until a character is available
        JMP 	.-1	
        KRB     		/ Read character
	AND 	[177]		/ Only keep the 7 lowest bits
	DCA	Key		/ Save the read character in Key
	TAD	Key		/ Return with the character in AC as well
	JMP I 	GetKey
/]


//   _____                        __  __
//  |__  /   ___   _ __    ___   |  \/  |
//    / /   / _ \ | '__|  / _ \  | |\/| |
//   / /_  |  __/ | |    | (_) | | |  | |
//  /____|  \___| |_|     \___/  |_|  |_|
//
// Input iP1	The address before the start of block to be filled
// 	 len 	Negitive number of bytes to be filled
//
/[
ZeroM,	0
	CLA
ZeroM0,	DCA I 	iP1
	ISZ	cnt
	JMP 	ZeroM0
	JMP I 	ZeroM
/]


//   ____    _      _           ____
//  / ___|  | | __ (_)  _ __   / ___|   _ __
//  \___ \  | |/ / | | | '_ \  \___ \  | '_ \
//   ___) | |   <  | | | |_) |  ___) | | |_) |
//  |____/  |_|\_\ |_| | .__/  |____/  | .__/
//                     |_|             |_|
//
// Advance 'src' to point to the first non-space character
//
// Inputs: 	src, KbufL
// Outputs: 	src, KbufL
//
/[
SkipSp,0
	CLA
SkipS0,	TAD I 	src
	TAD	[-40]		/ <SPACE>
	SZA
	JMP I 	SkipSp
	JMS 	IncSrc		/ src++
	TAD	KBufL
	TAD 	[-1]
	DCA 	KBufL
	JMP	SkipS0	
/]


//   ___                  ____
//  |_ _|  _ __     ___  / ___|   _ __    ___
//   | |  | '_ \   / __| \___ \  | '__|  / __|
//   | |  | | | | | (__   ___) | | |    | (__
//  |___| |_| |_|  \___| |____/  |_|     \___|
//
/[
IncSrc,	0
	CLA
	TAD 	src
	IAC
	DCA	src
	JMP I 	IncSrc
/]

//
//      _                      ____          _
//     / \     _ __    _ __   |  _ \   ___  | |_
//    / _ \   | '_ \  | '_ \  | | | | / __| | __|
//   / ___ \  | |_) | | |_) | | |_| | \__ \ | |_
//  /_/   \_\ | .__/  | .__/  |____/  |___/  \__|
//            |_|     |_|
//
// Store AC at the end of the dst array, increment the dst pointer
// Returns with AC zero
//
/[
AppDst,	0
	DCA I 	dst		/ Store it in the destination array
	ISZ	dst		/ Increment dst pointer
	ISZ 	TokBuf+2	/ Increment length of destination
	JMP I 	AppDst
/]


//   ____                    _
//  / ___|   _   _   _ __   | |_    __ _  __  __
//  \___ \  | | | | | '_ \  | __|  / _` | \ \/ /
//   ___) | | |_| | | | | | | |_  | (_| |  >  <
//  |____/   \__, | |_| |_|  \__|  \__,_| /_/\_\
//           |___/
/[
Syntax,	JMS 	TxtOut; SynErr
	JMP I	Prompt
/]


//					      _____   _  _      ___     ___
//					     |___  | | || |    / _ \   / _ \
//					        / /  | || |_  | | | | | | | |
//					       / /   |__   _| | |_| | | |_| |
//					      /_/       |_|    \___/   \___/
//					    

//					      _____    __      ___     ___
//					     |___  |  / /_    / _ \   / _ \
//					        / /  | '_ \  | | | | | | | |
//					       / /   | (_) | | |_| | | |_| |
//					      /_/     \___/   \___/   \___/


*7755
/[
MEMEND,			/ Last address before RIM loader
	ZBLOCK 22
/]

$

