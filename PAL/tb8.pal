//
// TB8 - Tiny BASIC for PDP8
// Version 0.01
//
// Project repository at github.com/SmallRoomLabs/TB8
//
// Copyright (c) 2020 Mats Engstrom
// Licensed under the MIT license
//

/NL0000=CLA			/ 0
/NL0001=CLA IAC			/ 1
/NL0002=CLA CLL CML RTL		/ 2
/NL0003=CLA STL IAC RAL		/ 3
/NL0004=CLA CLL IAC RTL		/ 4
/NL0006=CLA STL IAC RTL		/ 6
/NL0100=CLA IAC BSW		/ 100    64(dec)
/NL2000=CLA CLL CML RTR 		/ 2000 1024(dec)
/NL4000=CLA CLL CML RAR		/ 4000 2048(dec)
/NL3777=CLA CLL CMA RAR		/ 3777 2047(dec) 
/NL5777=CLA CLL CMA RTR		/ 5777 3071(dec)
/NL6000=CLA STL IAC RTR		/ 6000 3072(dec)
/NL7775=CLA CLL CMA RTL		/ 7775 4093(dec)
/NL7776=CLA CLL CMA RAL		/ 7776 4094(dec)
NL7777=CLA CMA 			/ 7777 4095(dec)

/NLM3=NL7775			/ -3
/NLM2=NL7776			/ -2
NLM1=NL7777			/ -1

SkpZER=SZA		/ Skip if Zero Accumulator
SkpNOZ=SNA		/ Skip if Nonzero Accumulator
SkpNEG=SMA		/ Skip if Minus Accumulator
SkpPOS=SPA		/ Skip if Positive Accumulator
SkpNE0=SMA SZA		/ Skip if Less than or Equal to Zero
SkpGT0=SPA SNA 		/ Skip if Greater than Zero


*0	
//					       ___     ___     ___     ___
//					      / _ \   / _ \   / _ \   / _ \
//					     | | | | | | | | | | | | | | | |
//					     | |_| | | |_| | | |_| | | |_| |
//					      \___/   \___/   \___/   \___/
/[
IRQ,	0			/ Placeholder for future IRQ handler
	JMP I IRQ

//                                   _           _       _
//  __/\__   __   __   __ _   _ __  (_)   __ _  | |__   | |   ___   ___
//  \    /   \ \ / /  / _` | | '__| | |  / _` | | '_ \  | |  / _ \ / __|
//  /_  _\    \ V /  | (_| | | |    | | | (_| | | |_) | | | |  __/ \__ \
//    \/       \_/    \__,_| |_|    |_|  \__,_| |_.__/  |_|  \___| |___/
//

Key,	.-.			/ Last read key
KBufL,	.-.			/ Current length of string in KBuf

tmp,;tmp1,	.-.			/ Generic temporary variable
tmp2,;A,;tmpH,	.-.			/ Generic temporary variable
tmp3,;B,;tmpL,	.-.			/ Generic temporary variable

*10
PrintP,	.-.			/ Pointer to string to be printed
KBufP,	.-.			/ Pointer to the first free location in KBuf
iP1,	.-.			/ Generic memory pointer
iP2,	.-.			/ Generic memory pointer

*20
cnt,	.-.			/ Generic counter
cnt2,	.-.
src,	.-.			/ Generic source address
dst,	.-.			/ Generic destination address
ADDRS,  .-. /???
numH, 	.-.
numL,	.-.
lineH,	.-.
lineL,	.-.

Arg1,;Arg1H,	.-.
Arg1L,	.-.
Arg2,;Arg2H,	.-.
Arg2L,	.-.
C,;ResH,	.-.
D,;ResL,		.-.

Ctype,	.-.


// Variables for SDPRINT
SDLOOP,	-7			/COUNT OF SEVEN DIGITS
SDTWO,	260			/BASIC CODE FOR DIGITS
SDPLUS,	-15			/"SPACE". TO TYPE "+",REPLACE BY "-2"
SDMNS,	-3			/"MINUS"
SDCNT,	0			/STORAGE LOCATIONS
SDHIGH,	0
SDLOW,	0
SDHSUB,	0
SDLSUB,	0
SDBOX,	0
SDTEML,	0
SDGET,	0
SDPTR,	0

// Variables for DMUL
SIGNSW,	0
REST,	-2
MULTH,	0
MULTL,	0
MLTL,	0
MLTH,	0
MP3,	0
MP5,	0


// Variables for DIVIDE
DIVCNT,	0
DIVND1,	0
DIVND2,	0
DIVND3,	0
DIVND4,	0
HDIVSR,	0
LDIVSR,	0

M12,	-14			/ Constant -12(dec)
M13,	-15			/ Constant -13(dec)
M25,	-31			/ Constant -25(dec)
P127,	0177  			/ Constant
P3840,	7400  			/ Constant

DW1M,   364; 1100		/ Double Word constant 1000 000(dec)
DW100K,	30; 3240		/ Double Word constant 100 000(dec)
DW10K,	2; 3420			/ Double Word constant 10 000(dec)
DW1K,	0; 1750			/ Double Word constant 1000(dec)
DW100,	0; 144			/ Double Word constant 100(dec)
DW10,	0; 12			/ Double Word constant 10(dec)
DW1,	0; 1			/ Double Word constant 1(dec)

SDCONL,	
DWM1M,	7413; 6700		/ Double Word constant -100 0000(dec)
DWM100K,7747; 4540		/ Double Word constant -100 000(dec)
DWM10K,	7775; 4360		/ Double Word constant -10 000(dec)
DWM1K,	7777; 6030		/ Double Word constant -1 000(dec)
DWM100	7777; 7634		/ Double Word constant -100(dec)
DWM10,	7777; 7766		/ Double Word constant -10(dec)
DWM1,	7777; 7777		/ Double Word constant -1(dec)

IntOut,	IntOuX
Prompt, PrompX
/]

*200
//					       ___    ____     ___     ___
//					      / _ \  |___ \   / _ \   / _ \
//					     | | | |   __) | | | | | | | | |
//					     | |_| |  / __/  | |_| | | |_| |
//					      \___/  |_____|  \___/   \___/

//                  _                    _
//  __/\__    ___  | |_    __ _   _ __  | |_
//  \    /   / __| | __|  / _` | | '__| | __|
//  /_  _\   \__ \ | |_  | (_| | | |    | |_
//    \/     |___/  \__|  \__,_| |_|     \__|
//
/[

	KCC     		/ Clear keyboard flag
	JMS 	TxtOut; Greet	/ Print greeting/header

//   ____                                       _
//  |  _ \   _ __    ___    _ __ ___    _ __   | |_
//  | |_) | | '__|  / _ \  | '_ ` _ \  | '_ \  | __|
//  |  __/  | |    | (_) | | | | | | | | |_) | | |_
//  |_|     |_|     \___/  |_| |_| |_| | .__/   \__|
//                                     |_|
//
PrompX,	CLA			/ Clear buffers
	DCA	lineH
	DCA	lineL
	TAD 	[-10-120]
	DCA 	cnt
	TAD 	[TokBuf-1]
	DCA 	iP1
	JMS 	ZeroM

	JMS 	TxtOut; Prmpt	/ Print TB8 prompt

	JMS 	ReadLi		/ Collect one line of text from the user.
				/ ReadLi returns with the text in KBuf[]
				/ and the length of text in KBufL

	JMS	Tokeni		/ Tokenize the string. It's hardcoded to
				/ use KBuf[] and KBufL as the source and
				/ TokBuf[] as destination

	/
	/ Check if this is a direct command or if it should be inserted
	/ into the code buffer. A direct command lacks the line number
	/ which then will have a zero value.
	/
	CLA	
	TAD 	(TokBuf-1)	/ Point to start of tokenized data
	DCA 	iP1
	TAD I 	iP1		/ Is LineNo High zero?
	SZA
	JMP	NotDir
	TAD I 	iP1		/ Is LineNo Low zero?
	SZA
	JMP 	NotDir

	/
	/ No line number given, so this is a direct command.
	/ Currently only RUN, LIST, NEW and FREE are accepted as
	/ direct commands
	/
	ISZ 	iP1		/ Skip the length
	TAD I 	iP1		/ Retrieve the command
	SkpNOZ			/ If just an empty line then 
	JMP I 	Prompt		/   go prompt again
	
	/ Verify that the command is within the range of direct commands. If 
	/ outside the allowed range the CkRang will print error and abort
	JMS	CkRang; tkFREE; tkRUN

	TAD	[tkOFS1+JMPTB1]
	DCA 	JMPVE1
	TAD I	JMPVE1
	DCA 	JMPVE1
	JMP I	JMPVE1

JMPVE1,	NOP
JMPTB1,	dcFREE		/ tkFREE = -50 7730
	dcNEW		/ tkNEW  = -47 7731
	dcLIST		/ tkLIST = -46 7732
	dcRUN		/ tkRUN  = -45 7733


	/
	/ First search for the line in the code base and remove it if it's there
	/ already. Then check if the new line is not empty and insert it into
	/ the code base.
	/
NotDir,	CLA CLL
	TAD I	(TokBuf)
	DCA 	NumH
	TAD I	(TokBuf+1)
	DCA 	NumL
	JMS	FndLine		/ Locate line, return pointer in src
	SZL			/ L is 0 if exact line not found, so skip deleting
	JMS	CodDel		/ Delete line pointed to by src
	CLA			/ Now check if new line is empty
	TAD 	TokBuf+2	/  I.E length is 2
	TAD	[-2]
	SNA 			/ Skip if length is not 2
	JMP I	Prompt

	CLA			/ Now make a hole in the code
	TAD 	TokBuf+2	/ Add 2 to the length to fit LineNo
	TAD	[2]
	DCA	cnt
	TAD	src		/ The destination is 'cnt' away
	TAD	cnt
	DCA	dst
	JMS 	CodIns

	CLA			/ Then copy the new tokens into the code
	TAD 	TokBuf+2
	DCA	cnt
	TAD 	src
	DCA 	dst
	TAD 	(TokBuf)
	DCA	src
	JMS	CodCpy
	JMP I	Prompt
/]


//       _          _       ___   ____    _____
//    __| |   ___  | |     |_ _| / ___|  |_   _|
//   / _` |  / __| | |      | |  \___ \    | |
//  | (_| | | (__  | |___   | |   ___) |   | |
//   \__,_|  \___| |_____| |___| |____/    |_|
//
// Direct Command LIST
/[
dcLIST,	JMS 	TxtOut; CRLF
	JMS	List
	JMP I	Prompt
/]

//       _          _____   ____    _____   _____
//    __| |   ___  |  ___| |  _ \  | ____| | ____|
//   / _` |  / __| | |_    | |_) | |  _|   |  _|
//  | (_| | | (__  |  _|   |  _ <  | |___  | |___
//   \__,_|  \___| |_|     |_| \_\ |_____| |_____|
//
// Direct Command FREE
//
/[
dcFREE,	JMS 	TxtOut; CRLF
	TAD 	(3777)		/ Search for location of last line of code
	DCA 	numH
	TAD 	(7777)
	DCA 	numL
	JMS	FndLin

	CLA CLL			/ Calculate difference between end-of-code 
	TAD 	(-CODEND)	/  memory and the last used location
	TAD 	src
	CIA
	DCA 	tmpL
	DCA	tmpH
	JMS I	IntOut;tmpH	/ Print the calculated number
	JMP I	Prompt

/]


//       _          _   _   _____  __        __
//    __| |   ___  | \ | | | ____| \ \      / /
//   / _` |  / __| |  \| | |  _|    \ \ /\ / /
//  | (_| | | (__  | |\  | | |___    \ V  V /
//   \__,_|  \___| |_| \_| |_____|    \_/\_/
//
//
// Direct Command NEW
//
/[
dcNEW,	NL7777			/ Set first byte of code buffer to
	DCA I	(Code)		/ end-of-code marker 7777
	JMP I	Prompt
/]



//          _____   _   _   ____
//    ___  | ____| | \ | | |  _ \
//   / __| |  _|   |  \| | | | | |
//  | (__  | |___  | |\  | | |_| |
//   \___| |_____| |_| \_| |____/
//
// Stop the running of the program by simply go back to the prompt
// again.
//
/[
cEND,	JMP I 	Prompt	
/]


//           ____    ___    _____    ___
//    ___   / ___|  / _ \  |_   _|  / _ \
//   / __| | |  _  | | | |   | |   | | | |
//  | (__  | |_| | | |_| |   | |   | |_| |
//   \___|  \____|  \___/    |_|    \___/
//
//
/[
cGOTO,
	CLA CLL

	ISZ	src
	JMS 	Expr; NumH
	JMS	FndLin		/ Set src. L=1 if exact match
	SZL 			/ Skip if Zero Link
	JMP 	Running
	JMP 	Syntax
/]


*400 
//					    
//					       ___    _  _      ___     ___
//					      / _ \  | || |    / _ \   / _ \
//					     | | | | | || |_  | | | | | | | |
//					     | |_| | |__   _| | |_| | | |_| |
//					      \___/     |_|    \___/   \___/



//       _          ____    _   _   _   _
//    __| |   ___  |  _ \  | | | | | \ | |
//   / _` |  / __| | |_) | | | | | |  \| |
//  | (_| | | (__  |  _ <  | |_| | | |\  |
//   \__,_|  \___| |_| \_\  \___/  |_| \_|
//
//
// Direct Command RUN
//
/[
dcRUN,	
	JMS 	TxtOut; CRLF

	TAD	(Code)	/ Start execution at first line of code
	DCA 	src

Runnin,	
	CLA CLL
	TAD I 	src	/ Save current line no
	DCA	lineH
	ISZ 	src
	TAD I 	src
	DCA	lineL
	ISZ 	src

	ISZ 	src	/ Skip length

Contin,	CLA CLL
	TAD I 	src
	TAD	(tkOFS2+JMPTB2)
	DCA 	JMPVE2
	TAD I	JMPVE2
	DCA 	JMPVE2
	JMP I	JMPVE2
JMPVE2,	NOP
JMPTB2,
	cEND		/ tkEND=	-35
	cRETURN		/ tkRETU=	-34
	cGOSUB		/ tkGOSU=	-33
	cGOTO 		/ tkGOTO=	-32
	cNEXT		/ tkNEXT=	-31
	cFOR		/ tkFOR=	-30
	cIFF 		/ tkIF=		-27
	cPRINT		/ tkPRIQ=	-26
	cPRINT		/ tkPRIN=	-25
	cGET		/ tkGET=	-24
	cINPUT 		/ tkINPU=	-23
	cLET		/ tkLET=	-22
	cCOLON		/ tkCOLO=	-21
	cREM		/ tkREM=	-20
/]


/
/
/
cRETURN,
cGOSUB,
cNEXT,
cFOR,
cGET,
cCOLON,
JMP I	Prompt




//    ____               _   ____           _
//   / ___|   ___     __| | |  _ \    ___  | |
//  | |      / _ \   / _` | | | | |  / _ \ | |
//  | |___  | (_) | | (_| | | |_| | |  __/ | |
//   \____|  \___/   \__,_| |____/   \___| |_|
//
/[
CodDel,	0
	CLA
	TAD	src		/ Get code line start
	TAD	[-1]		/ adjust for autoinc
	DCA	iP2		/ iP2 is autoincrementing destination
	TAD 	src
	IAC			/ Get length of line to delete
	IAC
	DCA 	tmp
	TAD I 	tmp
	TAD	src		/ Add the length to code line start 
	IAC			/ Adjust for LineNo and autoinc
	DCA	iP1		/ iP1 is autoincrementing source
CodDe0,	CLA
	TAD I 	iP1		/ Copy code data
	DCA I 	iP2
	TAD 	CODEND		/ Reached end of code?
	CIA
	TAD 	iP1
	SZA 
	JMP 	CodDe0
	JMP I 	CodDel
/]



//    ____               _   ___
//   / ___|   ___     __| | |_ _|  _ __    ___
//  | |      / _ \   / _` |  | |  | '_ \  / __|
//  | |___  | (_) | | (_| |  | |  | | | | \__ \
//   \____|  \___/   \__,_| |___| |_| |_| |___/
//
// Backwards copy 'cnt' bytes from 'src' to 'dst'
//
// Inputs: 	src, dst, cnt
// Modifies: 	src, dst, cnt, memory
// Outputs:
/[
CodIns,0
	CLA
	TAD	(1000)	/ TODO calculate length from end-of-code
	DCA	cnt


	TAD	cnt		/ Offset to last byte
	TAD 	src
	DCA 	src

	TAD	cnt		/ Offset to last byte
	TAD 	dst
	DCA 	dst

	TAD 	cnt		/ Make cnt negative for ISZ
	CIA
	DCA 	cnt

CodIn0,
	NLM1			/ src--
	TAD	src
	DCA 	src
	NLM1			/ dst--
	TAD	dst
	DCA 	dst
	TAD I	src		/ Move [src] -> [dst]
	DCA I 	dst
	ISZ	cnt		/ Loop until all 'cnt' bytes are moved
	JMP 	CodIn0
	JMP I	CodIns
/]


//    ____               _    ____
//   / ___|   ___     __| |  / ___|  _ __    _   _
//  | |      / _ \   / _` | | |     | '_ \  | | | |
//  | |___  | (_) | | (_| | | |___  | |_) | | |_| |
//   \____|  \___/   \__,_|  \____| | .__/   \__, |
//                                  |_|      |___/
/[
CodCpy,	0
	CLA
	TAD 	cnt
	IAC
	CMA
	DCA 	cnt
CodCp0,
	TAD I	src
	DCA I 	dst
	ISZ 	src
	ISZ 	dst
	ISZ 	cnt
	JMP 	CodCp0
	JMP I	CodCpy
/]


/[
cREM,	
	// TODO Make a real 24-bit increment here
	ISZ 	lineL
	CLA CLL
	TAD 	LineH
	DCA	NumH
	TAD 	LineL
	DCA 	NumL
	JMS 	FndLin
	JMP 	Running

/]



*600
//					       ___     __      ___     ___
//					      / _ \   / /_    / _ \   / _ \
//					     | | | | | '_ \  | | | | | | | |
//					     | |_| | | (_) | | |_| | | |_| |
//					      \___/   \___/   \___/   \___/



//   _____               _   _       _
//  |  ___|  _ __     __| | | |     (_)  _ __
//  | |_    | '_ \   / _` | | |     | | | '_ \
//  |  _|   | | | | | (_| | | |___  | | | | | |
//  |_|     |_| |_|  \__,_| |_____| |_| |_| |_|
//
// Find the starting address of the specified (or the next higher) line 
// number in the code area.
//
// Enter with desired line number in NumH/numL
// Returns with src pointing to the line. 
// L=1 if exact match, L=0 if the next higher is found
//
/[
FndLin,	0
	CLA
	TAD	[CODE]
	DCA	src

FndLi0,	CLA
	TAD	src
	DCA	tmp
	TAD I 	tmp			/ Fetch Line No from code
	SPA				/ If LineNoH is not negative we not at end
	JMP 	FndLiL			/ Exit with src at end of code and L=0
	DCA	tmpH
	ISZ 	tmp
	TAD I 	tmp
	DCA	tmpL

	TAD 	[tkGTEQ]		/ GREATER THAN OR EQUAL op for Compar
	JMS 	Compar; TmpH; NumH
	SZL 				/ Skip if no match
	JMP 	FndLiM

	ISZ 	src			/ Skip LineNoH
	ISZ 	src			/ Skip LineNoL
	CLA
	TAD	src			/ Get length			
	TAD I	src			/   and skip over the length as well
	DCA 	src
	JMP	FndLi0

/
/ Found a line that is either equal or larger than the desired line no
/ so compare Tmp and Num to see if they're equal and then return L=1, 
/ else return L=0
/
FndLiM,					
	CLA
	TAD 	TmpH
	CIA
	TAD 	NumH
	SZL
	JMP 	FndLiL
	CLA
	TAD 	TmpL
	CIA
	TAD 	NumL
	SZL
	JMP 	FndLiE

FndLiL,	CLL			/ Found larger, return with L=0
	JMP I 	FndLin		/ Exit with src pointing to start of line

FndLiE,	CLL CML			/ Found exact, return with L=1
	JMP I 	FndLin		/ Exit with src pointing to start of line

/]


*1000
//					      _    ___     ___     ___
//					     / |  / _ \   / _ \   / _ \
//					     | | | | | | | | | | | | | |
//					     | | | |_| | | |_| | | |_| |
//					     |_|  \___/   \___/   \___/


//          ___   _____
//    ___  |_ _| |  ___|
//   / __|  | |  | |_
//  | (__   | |  |  _|
//   \___| |___| |_|
//
// IF <expr1> <cond> <expr2> THEN <code>
/[

cIFF,	ISZ 	src
	JMS 	Expr; left	/ Get expression #11

	CLA CLL			/ Get the condition
	TAD I	src
	JMS 	CkRang; tkLT; tkEQ / Verify valid comparison token
	ISZ	src
	DCA	IFcomp		/ Store it for later 

	JMS 	Expr; right	/ Get expression #2

	CLA CLL			/ Get the THEN 
	TAD I	src
	JMS	CkRang; tkTHEN; tkTHEN / Verify THEN token
	ISZ	src

	CLA CLL			/ Compare the expressions using stored
	TAD 	IFcomp		/ comparison mode
	JMS	Compar; Left; Right

	SZL			/ Skip on L=0 (failed comparison)
	JMP 	Contin		/ If successful comparison continue parsing the line]

	/
	/ The comparison failed, so we need to find the start of the next line
	/ and start running from there. The current line is stored in lineH/LineL
	/
	// TODO Make a real 24-bit increment here
	ISZ 	lineL
	CLA CLL
	TAD 	LineH
	DCA	NumH
	TAD 	LineL
	DCA 	NumL
	JMS 	FndLin
	JMP 	Running

IFcomp,	0
left,	0;0
right,	0;0
/]


//          _       _____   _____
//    ___  | |     | ____| |_   _|
//   / __| | |     |  _|     | |
//  | (__  | |___  | |___    | |
//   \___| |_____| |_____|   |_|
//
//
/[
cLET,
	ISZ 	src
	CLA CLL
	TAD I 	src		/ Check if token is Variable
	JMS 	CkRang; tkVAR; tkVAR / Check if token is Variable

	ISZ 	src
	CLA CLL
	TAD I 	src		/ Get destination variable address
	JMS 	UCase
	TAD 	(-301)		/ Ucase sets parity, so subtract A plus parity
	JMS 	CkRang; 0; 31	/ Verify A-Z
	CLL RAL
	TAD 	(AZvars)
	DCA	cLetDst

	ISZ 	src
	CLA CLL
	TAD I 	src
	JMS 	CkRang; tkEQ; tkEQ / Check if token is "="

	ISZ 	src
	JMS	Expr
cLetDst,0


	/
	/ Skip over the final NIL or the COLON on the line
	/ and go back to process more tokens.
	/
cLetEx,	
	ISZ 	src		/ skip the NIL or COLON
	JMP 	Running

/]


//          ___   _   _   ____    _   _   _____
//    ___  |_ _| | \ | | |  _ \  | | | | |_   _|
//   / __|  | |  |  \| | | |_) | | | | |   | |
//  | (__   | |  | |\  | |  __/  | |_| |   | |
//   \___| |___| |_| \_| |_|      \___/    |_|
//
/[
cINPUT, 
	ISZ 	src
	CLA CLL
	TAD I 	src		/ Check if token is Variable
	JMS 	CkRang; tkVAR; tkVAR / Check if token is Variable

	ISZ 	src
	CLA CLL
	TAD I 	src		/ Get destination variable address
	JMS 	UCase
	TAD 	(-301)		/ Ucase sets parity, so subtract A plus parity
	JMS 	CkRang; 0; 31	/ Verify A-Z
	CLL RAL
	TAD 	(AZvars)
	DCA	cInpDst
	ISZ 	src

	TAD 	src		/ Save src as it's getting destroyed
	DCA 	cINPhl		/ by ReadLi

	JMS 	ReadLi		/ Collect one line of text from the user.
				/ ReadLi returns with the text in KBuf[]
				/ and the length of text in KBufL

	CLA CLL
	TAD	[KBuf]
	DCA	src
	JMS 	SkipSp		/ Skip spaces
	JMS	ATOL		/ Reads from src, stores in numH,numL

	CLA
	TAD	numH		/ Get high part of line number
	DCA I 	cInpDst
	ISZ 	cInpDst
	TAD	numL		/ Get low part of line number
	DCA I 	cInpDst

	TAD 	cINPhl		/ Restored clobbered src
	DCA 	src

	ISZ 	src
	JMP	Running

cINPhl,	0
cINPdst,0
/]



*1200
//					      _   ____     ___     ___
//					     / | |___ \   / _ \   / _ \
//					     | |   __) | | | | | | | | |
//					     | |  / __/  | |_| | | |_| |
//					     |_| |_____|  \___/   \___/

//          ____    ____    ___   _   _   _____
//    ___  |  _ \  |  _ \  |_ _| | \ | | |_   _|
//   / __| | |_) | | |_) |  | |  |  \| |   | |
//  | (__  |  __/  |  _ <   | |  | |\  |   | |
//   \___| |_|     |_| \_\ |___| |_| \_|   |_|
//
//
// tkVAR=  -1;	1		; tkVAR		/   Variable
// tkCONS= -2;	2		; tkCONS	/   Constant
// tkSTRI= -3;	42		; tkSTRI	/ " String start/end
//
// PRINT returns after NIL or tkCOLO
// PRINT outputs a CRLF before returning if the last token wasn't tkSEMI
// PRINT outputs a SPACE at tkSEMI
// PRINT outputs SPACED to next tabstop at tkCOMM
/[

cPRIfl,	0		/ Flag for not printing CRLF at the end

cPRIf0, NLM1		/ Turn off the NO-CRLF flag by setting it to -1
	DCA 	cPRIfl	/ and then falling into the increment function
			/ to have it end up as 0

cPRIf1,	ISZ	cPRIfl 	/ Set NO-CRLF flag and then fall into the regular 
	NOP		/ printing function. This is called whenever a
			/ tkSEMI is encountered. The NOP is needed here since 
			/ we go from 7777 to 0

cPRINT,
	ISZ	src
	CLA CLL
	TAD I 	src
	SkpNOZ
	JMP 	cPrEnd

	TAD 	(-tkCOLO)
	SkpNOZ
	JMP 	cPrEnd
	TAD 	(tkCOLO)

	TAD 	(-tkSEMI)
	SkpNOZ
	JMP 	cPRIf1		/ Got a semicolon, so set the flag, and try more printing
	TAD 	(tkSEMI)

	TAD 	(1)
	SkpNOZ
	JMP 	cPRINv		/ Print a variable
	TAD 	(1)
	SkpNOZ	
	JMP 	cPRINc		/ Print a constant

	/
	/ Print string
	/
cPRINs,	ISZ 	src		/ This will skip the leading "
	CLA			/ Get character to print
	TAD I 	src
	TAD 	[-tkSTRI]
	SNA			/ at end of message
	JMP 	foo
	TAD	[tkSTRI]
	JMS 	ChrOut		/ Call the character out for printing
	JMP 	cPRINs		/ Now do next character
foo,	ISZ	src
	JMP 	cPRIf0		/  yes, maybe do more printing?, but clear the NO-CRLF flag first


	/
	/ Print variable or constant
	/
cPRINv,
cPRINc,
	JMS 	Expr;tmpH
	JMS I	IntOut;tmpH
	JMP 	cPRIf0		/  yes, maybe do more printing?, but clear the NO-CRLF flag first

	/
	/ Print final CRLF (if not supressed) and go back to parse more tokens
	/
cPrEnd,	CLA			/ Is the CRLF supressed by the semicolon-flag?
	TAD	cPRIfl
	SkpGT0
	JMS 	TxtOut; CRLF
	JMP 	Running

/]


*1400
//					      _   _  _      ___     ___
//					     / | | || |    / _ \   / _ \
//					     | | | || |_  | | | | | | | |
//					     | | |__   _| | |_| | | |_| |
//					     |_|    |_|    \___/   \___/

//   _____          _                     _
//  |_   _|  ___   | | __   ___   _ __   (_)
//    | |   / _ \  | |/ /  / _ \ | '_ \  | |
//    | |  | (_) | |   <  |  __/ | | | | | |
//    |_|   \___/  |_|\_\  \___| |_| |_| |_|
//
// Tokenizes the NUL-terminated string in KBuf and stores the tokens 
// in TokBuf.  The string needs to have a trailing <space> in order to
// not lose the last token on the line.
//
//
/[
Tokeni,	0
	CLA CLL
	TAD	[KBuf]
	DCA	src
	TAD 	[TokBuf]
	DCA	dst
	
	JMS 	SkipSp		/ Skip spaces

	/
	/ Parse the line number and store it in the destination array
	/
	JMS	ATOL		/ Reads from src, stores in numH,numL

	CLA
	TAD	numH		/ Get high part of line number
	JMS	AppDst		/ Store in dst array
	TAD	numL		/ Get low part of line number
	JMS	AppDst		/ Store in dst array
	JMS 	AppDst		/ Clear the length

	/
	/ Start scanning for tokens
	/
TokenL,	/ TOKEN LOOP
	JMS 	SkipSp		/ Skip spaces
	CLA			/ Init iP1 to beginning of list of commands
	TAD	[CmdTxt-1]	
	DCA	iP1
	TAD	src		/ Save the start of possible token
	DCA	srcHld

	/
	/ Try matching the token with the command from the list
	/
Token1,	CLA
	TAD I 	iP1		/ Get character from command list
	SNA			/ Check if at end of command list (NULL)
	JMP	Token4		/   unknown command, go test is number or variable

	SPA			/ If command char is negative we have matched
	JMP 	TokenM		/   a full command.

	DCA	tmp		/ Before comparing the command char with the keybuf
				/ char, we need to uppercase and parity-fix the
				/ keybuf char. So stash the command char while
				/ doing that.
	TAD I 	src		/ Get keybuf char
	JMS 	UCase

	CMA			/ Now compare command char with keybuf char
	IAC
	TAD 	tmp
	SZA			
	JMP	TokenF		/ No match of chars, go skip chars until the
				/   next command

	ISZ	src		/ Match, src++. go try the next pair 
	JMP	Token1		/   of characters

	/
	/ No match for current entry in command list, but it
	/ can also be that we reached the end of the token.
	/
TokenF,	CLA CLL			/ Check if src character is NULL
	TAD I 	src		
	SNA
	JMP 	TokenD		/ We're done, the entire line is processed
	CLA			/ Match fail, restore src so we can start matching
	TAD	srcHld		/  the current token from its beginning
	DCA	src
Token3,	CLA			/ Skip to next entry in the command list
	TAD I 	iP1
	SMA 			/ Check if end at command
	JMP 	Token3		/   not yet, loop some more characters
	JMP	Token1

	/
	/ It's not one of the standard defined tokens, so test it for a 
	/ variable A to Z
	/
Token4,	CLA CLL
	TAD I	src
	TAD 	[-101]		/ Subtract ASCII A
	SPA
	JMP	Token5		/ Not A..Z, go check if it's a number
	TAD 	[-32]		/ Check if character is <= than Z
	SMA
	JMP	Token5		/ Not A..Z, go check if it's a number
	CLA CLL
	TAD 	[tkVAR]		/ Store variable token in dst array
	JMS 	AppDst
	TAD I 	SRC		/ Store variable name as is
	JMS 	AppDst
	ISZ	src		/ src++, Advance to next character
	JMP 	TokenL		/ Continue scanning for more tokens

	/
	/ Does the token start with a digit? Then assume it's a number
	/
Token5,	CLA CLL
	TAD I	src
	TAD	[-60]		/ subtract '0'
	SPA
	JMP  	Token6		/ Nope, not a digit
	TAD 	[-12]		/ Check if number is less than 10
	SMA
	JMP  	Token6		/ Nope, not a digit
	JMS	ATOL		/ Reads from src, stores in numH,numL, returns cnt used in AC
	CLA CLL
	TAD 	[tkCONS]	/ Store constant token in dst array
	JMS 	AppDst
	TAD 	numH		/ Store the number in dst array
	JMS 	AppDst
	TAD 	numL		/ Store the number in dst array
	JMS 	AppDst
	ISZ	src		/ src++, Advance to next character
	JMP 	TokenL		/ Continue scanning for more tokens

	/
	/ Does the token start with a quote? Then it's a string
	/
Token6,	CLA CLL
	TAD I	src
	TAD	(-42)
	SkpZER
	JMP 	Syntax
	CLA CLL
	TAD 	[tkSTRI]	/ Store string token in dst array
	JMS 	AppDst
TknS,	ISZ 	src
	CLA			/ Get character to print
	TAD I 	src
	TAD 	(-42)
	SNA			/ at end of message
	JMP 	TknSE
	TAD	(42)
	JMS 	AppDst
	JMP 	TknS

TknSE,	CLA CLL
	TAD 	[tkSTRI]	/ Store string token in dst array
	JMS 	AppDst
	ISZ	src		/ src++, Advance to next character
	JMP 	TokenL		/ Continue scanning for more tokens

	/
	/ We matched a token, so store it in the dst array
	/
TokenM,
	DCA	tmp
	TAD	tmp
	JMS	AppDst		/ Store in dst array
	TAD 	tmp
	TAD	[-tkREM]	/ Test is token was a REM
	skpZER		
	JMP 	TokenL		/ No, just continue scanning for more tokens
foo1,	TAD I 	src
	SkpNOZ
	JMP 	TokenD
	JMS 	AppDst
	ISZ 	src
	JMP	foo1

	/
	/ Reached the end of the input string, so terminate
	/ the output with a NUL-token and return to caller
	/
TokenD,	/ TOKEN DONE
	CLA
	JMS	AppDst
	JMP I 	Tokeni

srcHld,	0
/]


*1600
//					      _    __      ___     ___
//					     / |  / /_    / _ \   / _ \
//					     | | | '_ \  | | | | | | | |
//					     | | | (_) | | |_| | | |_| |
//					     |_|  \___/   \___/   \___/

//   _   _    ____
//  | | | |  / ___|   __ _   ___    ___
//  | | | | | |      / _` | / __|  / _ \
//  | |_| | | |___  | (_| | \__ \ |  __/
//   \___/   \____|  \__,_| |___/  \___|
//
//
/[
UCase, 	0
	AND 	(0177)		/ Remove parity using mask 000 001 111 111
	TAD 	(-141)		/ Bias it with negative ASCII "a"
	SMA
	TAD 	(-40)		/ Make it upper case
	TAD 	(341)		/ Restore bias + set parity
	JMP I 	UCase
/]

//
//      _                      ____          _
//     / \     _ __    _ __   |  _ \   ___  | |_
//    / _ \   | '_ \  | '_ \  | | | | / __| | __|
//   / ___ \  | |_) | | |_) | | |_| | \__ \ | |_
//  /_/   \_\ | .__/  | .__/  |____/  |___/  \__|
//            |_|     |_|
//
// Store AC at the end of the dst array, increment the dst pointer
// Returns with AC zero
//
/[
AppDst,	0
	DCA I 	dst		/ Store it in the destination array
	ISZ	dst		/ Increment dst pointer
	ISZ 	TokBuf+2	/ Increment length of destination
	JMP I 	AppDst
/]


//   ____    _      _           ____
//  / ___|  | | __ (_)  _ __   / ___|   _ __
//  \___ \  | |/ / | | | '_ \  \___ \  | '_ \
//   ___) | |   <  | | | |_) |  ___) | | |_) |
//  |____/  |_|\_\ |_| | .__/  |____/  | .__/
//                     |_|             |_|
//
// Advance 'src' to point to the first non-space character
//
// Inputs: 	src, KbufL
// Outputs: 	src, KbufL
//
/[
SkipSp,0
	CLA
SkipS0,	TAD I 	src
	TAD	[-40]		/ <SPACE>
	SZA
	JMP I 	SkipSp
	ISZ	src		/ src++
	TAD	KBufL
	TAD 	[-1]
	DCA 	KBufL
	JMP	SkipS0	
/]


//   _____                        __  __
//  |__  /   ___   _ __    ___   |  \/  |
//    / /   / _ \ | '__|  / _ \  | |\/| |
//   / /_  |  __/ | |    | (_) | | |  | |
//  /____|  \___| |_|     \___/  |_|  |_|
//
// Input iP1	The address before the start of block to be filled
// 	 len 	Negitive number of bytes to be filled
//
/[
ZeroM,	0
	CLA
ZeroM0,	DCA I 	iP1
	ISZ	cnt
	JMP 	ZeroM0
	JMP I 	ZeroM
/]


//   _       _         _
//  | |     (_)  ___  | |_
//  | |     | | / __| | __|
//  | |___  | | \__ \ | |_
//  |_____| |_| |___/  \__|
//
/[
List,0
	CLA
	TAD	[CODE-1]
	DCA	iP1

ListL0,	CLA
	IAC
	TAD  	iP1		/ Print the line number
	DCA 	.+5
	TAD I	iP1		/ Check if linenumber is negative
	SPA			/  if so we reached end of code and
	JMP I	List		/  will return to caller
	JMS I	IntOut; 0
	ISZ	iP1		/ Skip over the low part of line number
	ISZ	iP1		/ Skip over the length

ListL1,	CLA			/ Process the tokens
	TAD I 	iP1		/ Get token and ajust since we want to find the end
				/   of the token before the correct token
	SNA			/ Is the 'token' 0000/EOL?
	JMP 	ListCR		/   yes, print CRLF

	IAC			
	SNA			/ Is it variable/7777?
	JMP 	ListVa		/  yes, go print the name of the variable

	IAC
	SNA			/ Is it constant/7776?
	JMP	ListCo		/  yes, go print the value of the constant

	IAC
	SNA			/ Is it "/7775?
	JMP	ListSt		/   yes, go print ASCII until next "
	TAD 	[-1]		/   no, undo the increment

	DCA	tmp		/ Store the token
	TAD	[CmdTxt-1]	/ Begin searching the command table for the token
	DCA	iP2

ListL2,	CLA
	TAD I 	iP2
	SNA
	HLT			/ Didn't find the token
	CMA
	TAD	tmp
	SZA
	JMP	ListL2		/ Continue scanning for token

	JMS 	SpcOut
	TAD 	iP2
	IAC
	DCA	.+2
	JMS 	TxtOut; 0
	NOP
	TAD 	(-7756)		/ Test for tkREM
	SkpNOZ
	JMP 	ListPl		/ If it was REM then print the rest of line as-is
	JMP  	ListL1		/ Continue in current line

ListCR,	JMS 	TxtOut; CRLF
	JMP 	ListL0

ListVa,	JMS 	SpcOut
	TAD I 	iP1		/ 
	JMS 	ChrOut
	JMP  	ListL1		/ Continue in current line

ListCo,	JMS 	SpcOut
	TAD 	iP1
	IAC
	DCA	.+2
	JMS I	IntOut; 0
	ISZ 	iP1
	ISZ 	iP1
	JMP  	ListL1		/ Continue in current line

ListSt, JMS 	SpcOut
	TAD 	[42]
	JMS 	ChrOut
ListS0,	TAD I 	iP1
	TAD 	[3]
	SNA
	JMP 	ListS1
	TAD	[-3]
	JMS 	ChrOut
	JMP 	ListS0
ListS1, CLA
	TAD 	[42]
	JMS 	ChrOut
/	ISZ 	iP1
	JMP  	ListL1		/ Continue in current line

	/
	/ Print rest of string as-is plain ascii
	/
ListPl,	JMS 	SpcOut
ListP0,	TAD I 	iP1
	SkpNOZ
	JMP 	ListCR
	JMS 	ChrOut
	JMP 	ListP0
/]

*2000
//					      ____     ___     ___     ___
//					     |___ \   / _ \   / _ \   / _ \
//					       __) | | | | | | | | | | | | |
//					      / __/  | |_| | | |_| | | |_| |
//					     |_____|  \___/   \___/   \___/

//   _____
//  | ____| __  __  _ __    _ __
//  |  _|   \ \/ / | '_ \  | '__|
//  | |___   >  <  | |_) | | |
//  |_____| /_/\_\ | .__/  |_|
//                 |_|
//
// Evaluates an expression made up of one or more vars/consts with
// operands between them. The expression is simply parsed from left
// to right with no precedence.
// Parsing is started at 'src' and is terminated at <NIL> or tkCOLO
//
// JMS Expr
//	<Destination address>
//
// Inputs:   none
// Outputs:  double word to <Destination address>
// Destroys: tmp, Arg1, Arg2
//
//

/[
Expr,	0
	CLA CLL
	TAD I	Expr		/ Get address of param
	DCA 	exDst		/ Hold it in exDst until we need it
	ISZ 	Expr		/ Bump up return address

	JMS	GetVal; Arg1

ExLoop,	CLA CLL
	TAD I	src		/ Get next token
	SkpNOZ			/ Skip if not reached end-of-line
	JMP	ExDone

	TAD	[-tkPLUS]
	SkpNOZ			/ Skip if not Addition
	JMP	ExAddi
	IAC
	SkpNOZ			/ Skip if not Subtract
	JMP	ExSubt
	IAC
	SkpNOZ			/ Skip if not Multiply
	JMP	ExMult
	IAC
	SkpNOZ			/ Skip if not Divide
	JMP	ExDivi
/	JMP 	Syntax
	JMP 	ExDone

ExAddi,	ISZ	src
	JMS	GetVal; Arg2
	JMS 	Add		/ Arg1+Arg2 -> Res
	CLA CLL
	TAD 	ResH
	DCA 	Arg1H
	TAD 	ResL
	DCA 	Arg1L
	JMP	ExLoop

ExSubt,	ISZ	src
	JMS	GetVal; Arg2
	JMS 	Sub		/ Arg1-Arg2 -> Res
	CLA CLL
	TAD 	ResH
	DCA 	Arg1H
	TAD 	ResL
	DCA 	Arg1L
	JMP	ExLoop

ExMult,	ISZ	src
	JMS	GetVal; Arg2
	JMS 	Multip; Arg1; Arg2	/ Arg1*Arg2 -> A,B,C,D
	CLA CLL
	TAD 	ResH
	DCA 	Arg1H
	TAD 	ResL
	DCA 	Arg1L
	JMP	ExLoop

ExDivi,	ISZ	src
	JMS	GetVal; Arg2


	CLA; DCA negg
	CLA; TAD Arg1H	/ Check if negative dividend
	SMA
	JMP 	Mtes1
	JMS 	Negate; Arg1H	/ Always positive
	ISZ 	negg

Mtes1,	CLA;TAD Arg2H	/ Check if positive divisor
	SPA
	JMP 	Mtes2
	JMS 	Negate; Arg2H	/ Always negative
	CLA; TAD negg; TAD [-1]; DCA negg

Mtes2,	JMS	Divide; Arg1H; Arg2H
/	SZL			/ L is 1 is error
/	JMP 	Mtes4		
	CLA; TAD DIVND4; DCA 	ResH+1
	CLA; TAD DIVND3; DCA 	ResH
	CLA; TAD negg
	SZA
	JMP 	Mtes3
	JMS Negate; ResH
Mtes3,

	CLA CLL
	TAD 	ResH
	DCA 	Arg1H
	TAD 	ResL
	DCA 	Arg1L
	JMP	ExLoop



	/
	/ The full expression is evaluated, copy the final reasult to
	/ the requested destination and return to caller
	/
ExDone,	CLA CLL
	TAD 	Arg1
	DCA I 	ExDst
	ISZ	ExDst
	TAD 	Arg1+1
	DCA I 	ExDst

	JMP I	Expr
ExDst,	0
Negg,	0

/]

*2200
//					    
//					    
//					      ____    ____     ___     ___
//					     |___ \  |___ \   / _ \   / _ \
//					       __) |   __) | | | | | | | | |
//					      / __/   / __/  | |_| | | |_| |
//					     |_____| |_____|  \___/   \___/
//					    
//    ____          _    __     __          _
//   / ___|   ___  | |_  \ \   / /   __ _  | |
//  | |  _   / _ \ | __|  \ \ / /   / _` | | |
//  | |_| | |  __/ | |_    \ V /   | (_| | | |
//   \____|  \___|  \__|    \_/     \__,_| |_|
//
// Fetches the next value from the code at the current 'src'
// location. The value can be either a variable or constant.
// The value is put into the location specified by the parameter.
//
// JMS GetVal
//	<Destination address>
//
// Inputs:   none
// Outputs:  double word to <Destination address>
// Destroys: tmp
//
/[
GetVal,	0
	CLA CLL
	TAD I	GetVal          / Get address of param
	DCA 	tmp		/ Hold it in tmp until we need it
	ISZ 	GetVal		/ Bump up return address

	CLA CLL			/ Check if the value is a constant or a variable
	TAD I	src
	ISZ 	src

	IAC			/ tkVAR is -1, so after this AC should be 0 
	SkpNOZ			/ Skip if not tkVar
	JMP 	GVvar		/ Handle next token as a variable

	IAC			/ tkCONS is -2, so after this AC should be 0
	SkpZER			/ Skip if it is  tkCONS
	JMP 	Syntax		/ We're out of options, so print error meg

	/
	/ Get the constant value
	/
GVcon,
	CLA CLL
	TAD I	src
	DCA I 	tmp
	ISZ 	src
	ISZ 	tmp
	TAD I	src
	DCA I 	tmp
	ISZ 	src
	JMP I	GetVal

	/
	/ Get the value from a variable
	/
GVvar,
	CLA CLL
	TAD I 	src	/ Get the name of the variable (A-Z)
	TAD 	(-101)	/ Offset it to 0-25
	CLL RAL		/ Multiply by two for correct index into array
	TAD 	(AZvars) / Offset into the array
	DCA	GVsrc

	CLA CLL
	TAD I	GVsrc
	DCA I 	tmp
	ISZ 	GVsrc
	ISZ 	tmp
	TAD I	GVsrc
	DCA I 	tmp

	ISZ 	src
	JMP I	GetVal
GVsrc,	0
/]





//					      ____    _  _      ___     ___
//					     |___ \  | || |    / _ \   / _ \
//					       __) | | || |_  | | | | | | | |
//					      / __/  |__   _| | |_| | | |_| |
//					     |_____|    |_|    \___/   \___/
//
//					      ____     __      ___     ___
//					     |___ \   / /_    / _ \   / _ \
//					       __) | | '_ \  | | | | | | | |
//					      / __/  | (_) | | |_| | | |_| |
//					     |_____|  \___/   \___/   \___/
//					    
//					      _____    ___     ___     ___
//					     |___ /   / _ \   / _ \   / _ \
//					       |_ \  | | | | | | | | | | | |
//					      ___) | | |_| | | |_| | | |_| |
//					     |____/   \___/   \___/   \___/
//					    
//					      _____   ____     ___     ___
//					     |___ /  |___ \   / _ \   / _ \
//					       |_ \    __) | | | | | | | | |
//					      ___) |  / __/  | |_| | | |_| |
//					     |____/  |_____|  \___/   \___/
//
//					      _____   _  _      ___     ___
//					     |___ /  | || |    / _ \   / _ \
//					       |_ \  | || |_  | | | | | | | |
//					      ___) | |__   _| | |_| | | |_| |
//					     |____/     |_|    \___/   \___/
//					    
//					      _____    __      ___     ___
//					     |___ /   / /_    / _ \   / _ \
//					       |_ \  | '_ \  | | | | | | | |
//					      ___) | | (_) | | |_| | | |_| |
//					     |____/   \___/   \___/   \___/
//					    
//					    
//					      _  _      ___     ___     ___
//					     | || |    / _ \   / _ \   / _ \
//					     | || |_  | | | | | | | | | | | |
//					     |__   _| | |_| | | |_| | | |_| |
//					        |_|    \___/   \___/   \___/
//
//					      _  _     ____     ___     ___
//					     | || |   |___ \   / _ \   / _ \
//					     | || |_    __) | | | | | | | | |
//					     |__   _|  / __/  | |_| | | |_| |
//					        |_|   |_____|  \___/   \___/
//					    
//					      _  _     _  _      ___     ___
//					     | || |   | || |    / _ \   / _ \
//					     | || |_  | || |_  | | | | | | | |
//					     |__   _| |__   _| | |_| | | |_| |
//					        |_|      |_|    \___/   \___/
//					    
//					      _  _      __      ___     ___
//					     | || |    / /_    / _ \   / _ \
//					     | || |_  | '_ \  | | | | | | | |
//					     |__   _| | (_) | | |_| | | |_| |
//					        |_|    \___/   \___/   \___/
//					    
//					    
//					    






*3000

//    ____
//   / ___|   ___    _ __ ___    _ __     __ _   _ __
//  | |      / _ \  | '_ ` _ \  | '_ \   / _` | | '__|
//  | |___  | (_) | | | | | | | | |_) | | (_| | | |
//   \____|  \___/  |_| |_| |_| | .__/   \__,_| |_|
//                              |_|
//
// Compares two 24-bit words pointed to by the arguments
//
// AC should be set to one of these numbers to select the
// type of comparison
//
//	tkEQ= 	 -4
//	tkGTEQ=	 -5
//	tkGT=	 -6
//	tkNE=	 -7
//	tkLNEQ=	-10
//	tkLT=	-11
//
//	If comparison is false, return with L=0
//	If comparison is true, return with L=1
/[
Compar, 0
	DCA	Ctype

	TAD I	Compar          / Get address of param 1
	DCA	tmp
	TAD I 	tmp		/ Get high word of param1
	DCA 	Arg1H
	ISZ	tmp
	TAD I 	tmp		/ Get low word of param1
	DCA 	Arg1L
	ISZ 	Compar		/ Bump up return address

	TAD I	Compar          / Get address of param 2
	DCA	tmp
	TAD I 	tmp		/ Get high word of param2
	DCA 	Arg2H
	ISZ	tmp
	TAD I 	tmp		/ Get low word of param2
	DCA 	Arg2L
	ISZ 	Compar		/ Bump up return address

/SUBTRA,
	CLA CLL			/ not required if previous code always leaves AC==0
	TAD  	Arg2H+1
	CLL CMA CML IAC 	/ form 13-bit negative with no previous borrow
	TAD  	Arg1H+1		/ generates 0 for borrow, 1 for no borrow
	DCA  	ResH+1
	RAL			/ propagate "complemented" borrow
	TAD  	Arg2H		/ add previous stage borrow before forming negative
	CMA CML IAC		/ form 13-bit negative
	TAD  	Arg1H		/ generates 0 for borrow, 1 for no borrow
	DCA  	ResH

	CLA			/ After this ResH+1 is zero if both ResH
	TAD 	ResH		/ and ResH+1 was zero. And ResH can be tested
	CMA			/ for negative 
	DCA	tmp
	TAD 	ResH+1
	CMA
	AND 	tmp
	CMA
	DCA	ResH+1

	CLA CLL
	TAD	CTYPE		/ Calculate inexed jump based on CTYPE
	TAD     (tkOFS3+JMPTB3)
	DCA     JMPVE3
	TAD I   JMPVE3
	DCA     JMPVE3
	JMP I   JMPVE3
JMPVE3, NOP
JMPTB3,
  	CompLT			/  <   LESS THAN
	CompLE			/  <=  LESS THAN OR EQUAL
	CompNE			/  <>  NOT EQUAL
	CompGT			/  >   GREATER THAN
	CompGE			/  >=  GREATER THAN OR EQUAL
	CompEQ			/  =   EQUAL

CompEQ,	CLA
	TAD 	ResH+1
	SNA			/ Skip if not equal
	JMP 	CompaT
	JMP 	CompaF

CompGE,	CLA
	TAD 	ResH+1
	SNA			/ Skip if not equal
	JMP 	CompaT

CompGT,	/ Begin by testing if Arg1 is negative and Arg2 is positive
	/ if it is so then Arg1 can't be larger than Arg2 so we fail
	CLA
	TAD 	Arg1H
	SMA 			/ Skip if minus acc
	JMP 	CompL1
	CLA
	TAD	Arg2H
	SMA 			/ Skip if minus acc
	JMP 	CompaF

CompL1,	/  Then testing if Arg1 is positive and Arg2 is negative
	/ if it is so then Arg1 must be larger than Arg2 so we succeed
	CLA
	TAD 	Arg1H
	SPA 			/ Skip if positive acc
	JMP 	CompL2
	CLA
	TAD	Arg2H
	SPA 			/ Skip if positive acc
	JMP 	CompaT

CompL2,	/ Fall back on regular subtraction testing since we ruled out
	/ the cases where an overflow can cause incorrect
	CLA
	TAD 	ResH
	SPA 			/ Skip if minus
	JMP 	CompaF
	CLA
	TAD	ResH+1
	SZA
	JMP 	CompaT
	JMP 	CompaF


CompNE,	CLA
	TAD 	ResH+1
	SZA
	JMP 	CompaT
	JMP 	CompaF

CompLE,	CLA
	TAD 	ResH+1
	SNA			/ Skip if not equal
	JMP 	CompaT


CompLT,	/ Begin by testing if Arg1 is positive and Arg2 is negative
	/ if it is so then Arg1 can't be smaller than Arg2 so we fail
	CLA
	TAD 	Arg1H
	SPA 	 		/ Skip if plus acc
	JMP 	CompL3
	CLA
	TAD	Arg2H
	SPA 	 		/ Skip if plus acc
	JMP 	CompaF

CompL3,	/  Then testing if Arg1 is negative and Arg2 is positive
	/ if it is so then Arg1 must be smaller than Arg2 so we succeed
	CLA
	TAD 	Arg1H
	SMA			/ Skip if negative acc
	JMP 	CompL4
	CLA
	TAD	Arg2H
	SMA 			/ Skip if negtive acc
	JMP 	CompaT

CompL4,	/ Fall back on regular subtraction testing since we ruled out
	/ the cases where an overflow can cause incorrect
	CLA
	TAD 	ResH
	SPA 			/ Skip if plus
	JMP 	CompaT
	JMP 	CompaF

CompaF,	CLL			/ Comparison false, return with L=0
	JMP I 	Compar

CompaT,	CLL CML			/ Comparison true, return with L=1
	JMP I 	Compar


/]


*2200




*5000
//					      ____     ___     ___     ___
//					     | ___|   / _ \   / _ \   / _ \
//					     |___ \  | | | | | | | | | | | |
//					      ___) | | |_| | | |_| | | |_| |
//					     |____/   \___/   \___/   \___/

//   ___           _      ___            _
//  |_ _|  _ __   | |_   / _ \   _   _  | |_
//   | |  | '_ \  | __| | | | | | | | | | __|
//   | |  | | | | | |_  | |_| | | |_| | | |_
//  |___| |_| |_|  \__|  \___/   \__,_|  \__|
//
// SIGNED DECIMAL PRINT, DOUBLE PRECISION
// CALLING SEQUENCE:  JMS IntOut /SUBROUTINE CALLED
//                    HIADDR     /ADDRESS OF HIGH ORDER WORD
//                    RETURN     /RETURN WITH AC AND L CLEAR
/[
IntOuX,	0
	CLA CLL
	DCA	noblan
	TAD I 	IntOuX		/PICK UP ADDRESS OF HIGH-ORDER WORD
	DCA 	SDGET
	TAD I 	SDGET		/PICK UP HIGH-ORER WORD
	SMA CLA			/IS IT NEGATIVE?
	JMP	.+3		/TAD 	SDPLUS		/NO, GENERATE CODE FOR SPACE
	TAD 	SDMNS		/YES, GENERATE CODE FOR "MINUS"
	JMS 	DigOut		/TYPE IT OUT
	TAD I 	SDGET		/PICK UP HIGH-ORDER WORD AGAIN
	SPA			/IS IT POSITIVE?
	CMA CML			/NO, COMPLEMENT IT. SET LINK
	DCA 	SDHIGH		/STORE POSITIVE WORD FOR USE IN SUBROUTINE
	ISZ 	SDGET
	TAD I 	SDGET		/PICK UP LOW-ORDER WORD
	SZL			/IS LINK SET?
	CMA CLL IAC		/YES, FORM TWO'S COMPLEMENT
	SZL			/DID AC OVERFLOW FROM "IAC"?
	ISZ 	SDHIGH		/YES, CORRECT HIGH-ORDER WORD
	DCA 	SDLOW		/STORE POSITIVE LOW-ORDER WORD
	TAD 	SDLOOP		/INITIALIZE DIGIT COUNTER TO "7"
	DCA 	SDCNT
	TAD 	[DWM1M]		/INITIALIZE POINTER TO TABLE OF POWERS OF TEN
	DCA 	SDPTR
	ISZ 	IntOuX		/INDEX LINKAGE FOR CORRECT RETURN
SDARND,	TAD I	SDPTR		/PICK UP POWER OF TEN FOR USE IN SUBTRACT
	ISZ 	SDPTR
	DCA 	SDHSUB
	TAD I 	SDPTR
	ISZ 	SDPTR
	DCA 	SDLSUB
SDDO,	CLL			/DOUBLE PRECISION SUBTRACTION
	TAD	SDLSUB
	TAD	SDLOW
	DCA	SDTEML
	RAL
	TAD	SDHSUB
	TAD	SDHIGH
	SPA			/DID IT UNDERFLOW?
	JMP	SDOUT		/NO, COUNT IS DONE
	ISZ	SDBOX		/YES, COUNT NOT DONE. INDEX DIGIT
	DCA	SDHIGH		/DEPOSIT REMAINING HIGH-ORDER PORTION
	TAD	SDTEML		/RESTORE REMAINING LOW-ORDER PORTION
	DCA	SDLOW
	JMP	SDDO		/GO BACK AND SUBTRACT AGAIN
SDOUT, 	CLA
	TAD	SDBOX		/PICK UP RESULTING DIGIT
	SkpNOZ
	JMP	SDfix
Fix2,	ISZ 	noblan		/Set noblank flag since we printed a digit
	JMS	DigOut		/TYPE IT OUT
Fix1,	CLA
	DCA	SDBOX		/INITIALIZE DIGIT TO "0"
	ISZ	SDCNT		/HAVE WE TYPED "7" DIGITS
	JMP	SDARND		/NO, DETERMINE NEXT DIGIT
	TAD 	noblan		/ Check if we're still in blanking when exiting
	SkpNOZ 			
	JMS 	DigOut		/   if so we must print a 0 manually.
	JMP I	IntOuX		/YES, SUBROUTINE DONE. RETURN

SDfix,	CLA			/ We reach here when trying to print 0
	TAD 	noblan		/ Are we still in blanking?
	SkpNOZ 	
	JMP 	fix1
	CLA
	TAD 	SDBOX
	JMP 	fix2

noblan,	0
/]


//   ____                       _   _       _
//  |  _ \    ___    __ _    __| | | |     (_)
//  | |_) |  / _ \  / _` |  / _` | | |     | |
//  |  _ <  |  __/ | (_| | | (_| | | |___  | |
//  |_| \_\  \___|  \__,_|  \__,_| |_____| |_|
//
// Read a line from the TTY with editing
// The string is stored in KBuf and the length of the string
// is stored in KBufL
//
/[
ReadLi,	0
	CLA			/ Initialize keyboard buffer
	DCA	KBufL		/ Set length of string to zero
	TAD	[KBuf-1]	/ Point to beginning of keyboard buffer
	DCA	KBufP

ReadL0,
	JMS	GetKey

	/ Test key for BACKSPACE  10   8(dec)	delta 10
	/              LINEFEED   12  10(dec)	delta 2
	/              ENTER      15  13(dec)	delta 3
	/              DELETE    177 127(dec)	delta 162

	TAD	[-10]		/ Subtract BACKSPACE
	SNA			/ Test if it was BACKSPACE
	JMP	BACKSP

	TAD	[-2]		/ Subtract delta to LINEFEED
	SNA			/ Test if it was LINEFEED
	JMP	ReadL0		/ If so, ignore the key

	TAD	[-3]		/ Subtract delta to ENTER
	SNA			/ Test if it was ENTER
	JMP 	ReadE 		/ Yes, go add trailing space for tokenizer and
				/ then exit.

	TAD	[-162]		/ Subtract delta to DELETE
	SNA			/ Test if it was DELETE
	JMP	BACKSP		/ If so, then handle as a BACKSPACE

	CLA CLL			/ Reload the key value
	TAD 	Key
	TAD	[-40]		/ Is it a valid printable character i.e.
	SPA			/ greater or equal to SPACE
	JMP 	KeyERR

	CLA CLL			/ Check if keyboard buffer full
	TAD	KBufL 		/ Length of string in keyboard buffer
	TAD	[-120]		/ 80(dec)
	SMA
	JMP	KeyERR
	ISZ	KBufL

	CLA CLL			/ Reload the key value
	TAD 	Key
	TLS			/ Print the key
	DCA I 	KBufP		/ Store the key into the buffer
	JMP 	ReadL0

KeyERR,
	CLA			/ Print the BEL character to alert for error
	TAD 	[7]
	TLS
	JMP	ReadL0

ReadE, 	CLA			/ Add trailing space for tokenizer
	TAD 	[40]
	DCA I 	KBufP		
	JMP I 	ReadLi		/ Return back to caller


BACKSP,	CLA			/ Check if buffer is not empty
	TAD	KBufL	
	SNA
	JMP 	ReadL0		/ It's empty, ignore backspace 
	TAD	[-1]		/ Decrement string length	
	DCA	KBufL
	TAD 	KBufP		/ Decrement string pointer
	TAD	[-1]
	DCA	KBufP
	CLA			/ Print the backspace/erase sequence	
	JMS 	TxtOut; BsSpBs
	JMP 	ReadL0
/]

*5200
//					      ____    ____     ___     ___
//					     | ___|  |___ \   / _ \   / _ \
//					     |___ \    __) | | | | | | | | |
//					      ___) |  / __/  | |_| | | |_| |
//					     |____/  |_____|  \___/   \___/

//      _          _       _
//     / \      __| |   __| |
//    / _ \    / _` |  / _` |
//   / ___ \  | (_| | | (_| |
//  /_/   \_\  \__,_|  \__,_|
//
//  Adds 24 bits Arg1 and Arg2 into 24 bit Res
//
//  Returns AC=0 
//          L=1 if overflow
/[
Add,	0
	CLA CLL 
	TAD 	Arg1H+1
	TAD 	Arg2H+1 
	DCA 	ResH+1
	RAL 
	TAD 	Arg1H; 
	TAD 	Arg2H; 
	DCA 	ResH
	JMP I 	Add
/]


//   ____            _
//  / ___|   _   _  | |__
//  \___ \  | | | | | '_ \
//   ___) | | |_| | | |_) |
//  |____/   \__,_| |_.__/
//
//  Subtracts 24 bits Arg1 from Arg2 into 24 bit Res
//
//  Returns AC=0 
//          L=0 if underflow 
/[
Sub,	0
		CLA CLL
		TAD  	Arg2H+1
		CLL CMA CML IAC 	/ form 13-bit negative with no previous borrow
		TAD  	Arg1H+1		/ generates 0 for borrow, 1 for no borrow
		DCA  	ResH+1
		RAL			/ propagate "complemented" borrow
		TAD  	Arg2H		/ add previous stage borrow before forming negative
		CMA CML IAC		/ form 13-bit negative
		TAD  	Arg1H		/ generates 0 for borrow, 1 for no borrow
		DCA  	ResH
	JMP I	Sub
/]
//   ____    ___  __     __  ___   ____    _____
//  |  _ \  |_ _| \ \   / / |_ _| |  _ \  | ____|
//  | | | |  | |   \ \ / /   | |  | | | | |  _|
//  | |_| |  | |    \ V /    | |  | |_| | | |___
//  |____/  |___|    \_/    |___| |____/  |_____|
//
// BASED ON DEC-08-FMEA-LA 
// DOUBLE PRECISION DIVIDE SUBROUTINE,
// Stripped down from 48 bit Dividend to 24 bit
//
// CALLING SEQUENCE:
//         JMS DIVIDE
//	    ADDRESS OF HIGH ORDER DIVIDEND
//          ADDRESS OF HIGH ORDER DIVISOR
//
//         RETURN: DIVND3/AC = HIGH ORDER QUOTIENT
//                 DIVND4 = LOW ORDER QUOTIENT
//                 DIVND1 = HIGH ORDER REMAINDER
//                 DIVND2 = LOW ORDER REMAINDER
//
// IF DIVISOR<DIVIDEND; RESULTS UNSPECIFIED
//
/[
Divide,	0
	CLA
	DCA	DIVND1
	DCA	DIVND2

	TAD I	DIVIDE		/ Get Dividend address from parameters
	DCA	ADDRS
	ISZ	DIVIDE		/ Adjust return address

	TAD I	ADDRS		/ Dividend High
	DCA	DIVND3
	ISZ	ADDRS
	TAD I	ADDRS		/ Dividend Low
	DCA	DIVND4

	TAD I	DIVIDE		/ Get Divisor address from parameters
	DCA	ADDRS
	ISZ	DIVIDE		/ Adjust return address

	TAD I	ADDRS		/ Divisor High
	DCA	HDIVSR
	ISZ	ADDRS
	TAD I	ADDRS		/ Divisor Low
	DCA	LDIVSR
	
	TAD	M25			/ SETUP FOR 24 LOOPS
	DCA	DIVCNT		/ SET DIVIDE COUNT=24
	CLL
	JMP	DIV2

DIV3,	TAD	DIVND2		/ SHIFT HIGH DIVIDEND
	RAL			/ LEFT
	DCA	DIVND2
	TAD	DIVND1
	RAL
	DCA	DIVND1
	TAD	DIVND2		/ COMPARE DIVISOR;
	TAD	LDIVSR		/ WITH DIVISOR
	DCA	ADDRS
	RAL			/ GET CARRY
	TAD	DIVND1
	TAD	HDIVSR
	SNL
	JMP	DIV2-1
	DCA	DIVND1
	TAD	ADDRS
	DCA	DIVND2
	CLA
DIV2,	TAD	DIVND4		/ ROTATE LOW ORDER
	RAL			/ WORDS LEFT
	DCA	DIVND4
	TAD	DIVND3		/QUTOIENT BITS
	RAL
	DCA	DIVND3		/ ENTER FROM C(L)
	ISZ	DIVCNT		/ DONE 24?
	JMP	DIV3		/ NO: CONTINUE
	JMP I	DIVIDE		/ We're done, exit subroutine

/]


//   _   _                          _
//  | \ | |   ___    __ _    __ _  | |_    ___
//  |  \| |  / _ \  / _` |  / _` | | __|  / _ \
//  | |\  | |  __/ | (_| | | (_| | | |_  |  __/
//  |_| \_|  \___|  \__, |  \__,_|  \__|  \___|
//                  |___/
// Negate the 24 bit value pointed to by the parameter
// Returns the value in tmpH/tmpL
/[
Negate,	0
	CLA CLL
	TAD I	Negate          / Get address of parameter
	DCA	tmpH
	TAD 	tmpH
	IAC
	DCA	tmpL
	ISZ	Negate		/ Bump up return address

	TAD I	tmpL 
	CMA
	DCA I 	tmpL
	TAD I	tmpH
	CMA
	DCA I 	tmpH

	TAD I	tmpL 
	TAD 	[1] 
	DCA I 	tmpL
	RAL
	TAD I	tmpH
	DCA I 	tmpH

	JMP I	Negate
/]

//      _      _____    ___    _
//     / \    |_   _|  / _ \  | |
//    / _ \     | |   | | | | | |
//   / ___ \    | |   | |_| | | |___
//  /_/   \_\   |_|    \___/  |_____|
//
// Converts ascii text into a double word int ends at first non-digit.
// Reads from src, stores in numH,numL, returns cnt used in AC
//
/[ 
ATOL,	
	0
	CLA
	DCA	numH		/ Clear the multiplicator
	DCA 	numL

ATOL0,	TAD I 	src		/ Get character

	TAD	[-60]		/ subtract '0'
	DCA	tmp		/ save it as number 0 .. 9+
	TAD 	tmp		/ reload
	SPA
	JMP I 	ATOL		/ Done
	TAD 	[-12]		/ Check if number is less than 10
	SMA
	JMP I 	ATOL		/ Done

	CLA			/ We found a valid digit
	ISZ 	src		/ Tncrement the source address

	JMS	Multip		/ Multiply the summing up variable by 10
			numH
			DW10	

	CLA CLL			/ Copy result back to the summing up variable
	TAD	D
	DCA 	numL
	TAD	C
	DCA 	numH

	TAD	tmp		/ Add our number to the summing up variable
	TAD 	numL
	DCA 	numL
	RAL
	TAD 	numH
	DCA 	numH
	JMP 	ATOL0
/]



*5400
//					      ____    _  _      ___     ___
//					     | ___|  | || |    / _ \   / _ \
//					     |___ \  | || |_  | | | | | | | |
//					      ___) | |__   _| | |_| | | |_| |
//					     |____/     |_|    \___/   \___/
//					    

/]
//   __  __           _   _     _
//  |  \/  |  _   _  | | | |_  (_)  _ __
//  | |\/| | | | | | | | | __| | | | '_ \
//  | |  | | | |_| | | | | |_  | | | |_) |
//  |_|  |_|  \__,_| |_|  \__| |_| | .__/
//                                 |_|//
// DIGITAL-8-13-F
// SIGNED DOUBLE PRECISION MULTIPLY ROUTINE
// CALLING SEQUENCE:
//        JMS Multip
//        	<ADDRESS OF MULTIPLICAND(HIGH ORDER)>
//        	<ADDRESS OF MULTIPLIER(HIGH ORDER)>
//        
//  RETURNS HIGH TO LOW IN A,B,C,D
/[
Multip,	0
	CLL CLA
	TAD	REST		/-2
	DCA	SIGNSW		/SET SIGN SWITCH
	JMS	TSIGN		/FETCH AND SET SIGN
	TAD	MLTH		/RESULT IN MLTH,MLTL
	DCA	MULTH		/HIGH ORDER MULTIPLICAND
	TAD	MLTL
	DCA	MULTL		/LOW ORDER MULTIPLICAND
	JMS	TSIGN		/FETCH AND SET SIGN
	TAD	MULTL		/LOW ORDER MULTIPLICAND
	DCA	MiDst
	TAD	MLTL		/LOW ORDER MULTIPLIER
	JMS	MP4		/MULTIPLY
	DCA	D		/LOW ORDER
	TAD	MP5
	DCA	C		/HIGH ORDER
	TAD	MULTH		/HIGH ORDER MULTIPLICAND
	DCA	MiDst
	TAD	MLTL		/LOW ORDER MULTIPLIER
	JMS	MP4		/MULTIPLY
	TAD	C
	DCA	C
	RAL			/GET CARRY
	TAD	MP5
	DCA	B
	RAL			/GET CARRY
	DCA	A
	TAD	MULTL		/LOW ORDER MULTIPLICAND
	DCA	MiDst
	TAD	MLTH		/HIGH ORDER MULTIPLIER
	JMS	MP4		/MULTIPLY
	TAD	C
	DCA	C		/ADD
	RAL			/GET CARRY
	TAD	MP5
	TAD	B
	DCA	B
	RAL			/GET CARRY
	TAD	A
	DCA	A		/ADD
	TAD	MULTH		/HIGH ORDER MULTIPLICAND
	DCA	MiDst
	TAD	MLTH		/HIGH ORDER MULTIPLIER
	JMS	MP4
	TAD	B
	DCA	B
	RAL
	TAD	MP5
	TAD	A
	ISZ	SIGNSW		/ANSWER <0??
	JMP I	Multip		/NO: EXIT
	DCA	A		/YES
	TAD	D
	CMA CLL IAC		/NEGATE
	DCA	D
	TAD	C		/NEGATE
	JMS	COM
	DCA	C
	TAD	B
	JMS	COM		/NEGATE
	DCA	B
	TAD	A
	JMS	COM
	DCA	A		/ Added by MEM
	JMP I	Multip		/EXIT

MiDst,
COM,	0
	CMA
	SZL
	CLL IAC
	JMP I	COM

MiSrc,
TSIGN,	0
	TAD I	Multip		/FETCH ADDRESS
	DCA	ADDRS
	TAD I	ADDRS		/FETCH HIGH ORDER
	CLL
	SPA			/IS IT <0?
	CMA CML			/YES: COMPLEMENT, SET LINK
	DCA	MLTH
	ISZ	ADDRS
	TAD I	ADDRS		/FETCH LOW ORDER
	SZL			/WAS IT <0?
	ISZ	SIGNSW		/YES, ADD 1 TO SWITCH
	NOP
	SZL
	CMA CLL IAC		/COMPLEMENT, CLEAR LINK
	DCA	MLTL
	SZL			/CARRY?
	ISZ	MLTH		/YES
	ISZ	Multip
	JMP I 	TSIGN		/EXIT ROUTINE

MP4,	0		/UNSIGNED MULTIPLY
	DCA	MiSrc
	DCA	MP5
	TAD	M12		/COUNT 12 BITS
	DCA	MP3
	CLL
	TAD	MiSrc		/CARRY GOES INTO
	RAR			/LEFT OF MiSrc
	DCA	MiSrc		/TEST MULTIPLIER BIT
	TAD	MP5
	SNL			/A 1?
	JMP	.+3		/NO: DON'T ADD
	CLL			/YES: ADD
	TAD	MiDst
	RAR
	DCA	MP5
	ISZ	MP3		/DONE 12 BITS?
	JMP	MP4+6		/NO: CARRY IS IN C(L)
	TAD	MiSrc		/YES: DONE
	RAR
	CLL
	JMP I	MP4		/EXIT
/]


*5600
//					      ____     __      ___     ___
//					     | ___|   / /_    / _ \   / _ \
//					     |___ \  | '_ \  | | | | | | | |
//					      ___) | | (_) | | |_| | | |_| |
//					     |____/   \___/   \___/   \___/
//					    

//   ____                        _
//  |  _ \    __ _   _ __     __| |   ___    _ __ ___
//  | |_) |  / _` | | '_ \   / _` |  / _ \  | '_ ` _ \
//  |  _ <  | (_| | | | | | | (_| | | (_) | | | | | | |
//  |_| \_\  \__,_| |_| |_|  \__,_|  \___/  |_| |_| |_|
//
// DECUS 5-25  RANDOM NUMBER GENERATOR
// Returns 12 bit random number in AC and rndval
// Destroys tmp1,tmp2,tmp3
// 
/[
Random,	0
	CLA
	TAD	rseed1
	RAL
	AND	P3840	
	DCA	tmp3	
	TAD	rseed2	
	AND	P127	
	TAD	tmp3	
	RTL
	RTL
	RAL
	DCA	tmp1	
	TAD	rseed1	
	AND	P127
	RTL
	RTL
	RAL
	TAD	rseed2	
	DCA	tmp2	
	SZL
	ISZ	tmp1	
	NOP
	TAD	rseed1
	CLL	RAL	
	SZL
	ISZ	tmp2
	SKP
	ISZ	tmp1	
	NOP
	CLL
	TAD	rseed1	
	DCA	rseed1
	TAD	rseed2	
	RAL
	SZL
	ISZ	tmp1	
	NOP
	CLL
	TAD	tmp2	
	DCA	rseed2	
	TAD	rseed3	
	RAL
	TAD	rseed3	
	TAD	tmp1	
	DCA	rseed3	
	TAD	rseed3	
	JMP	I RANDOM

rseed3,;rndval,	0000  		/ 36bit random(seed) word High part
rseed2,		0000  		/ 36bit random(seed) word Middle part
rseed1,		0001  		/ 36bit random(seed) word Low part
/]

//    ____   _      ____
//   / ___| | | __ |  _ \    __ _   _ __     __ _
//  | |     | |/ / | |_) |  / _` | | '_ \   / _` |
//  | |___  |   <  |  _ <  | (_| | | | | | | (_| |
//   \____| |_|\_\ |_| \_\  \__,_| |_| |_|  \__, |
//                                          |___/
//
// Check that AC is within (inclusive) the specified bounds specified with
// two parameters following the call.
//
//  JMS ChRang
//      <lower bound value>
//      <upper bound value>
//
// Destroys tmp
//
/[

CkRang, 0
	DCA 	tmp		/ Save number to check

	/
	/ Check lower bound
	/
	CLA CLL
	TAD I	CkRang		/ Get lower bound value
	CLL
	CIA
	TAD	tmp
	SNL
	JMP 	Syntax
	ISZ 	CkRang		/ Bump return address

	/
	/ Check upper bound
	/
	CLA CLL
	TAD	tmp
	CIA
	TAD I	CkRang		/ Get upper bound value
	SNL
	JMP 	Syntax
	ISZ 	CkRang		/ Bump return address

	CLA CLL			/ Restore original AC/value-to-check
	TAD 	tmp
	JMP I	CkRang	
/]


Greet, 
	15;12
	ASCII "TB8 v0.1 [PDP-8 Tiny Basic Interpreter]"
	15;12;0


*6000
//					       __      ___     ___     ___
//					      / /_    / _ \   / _ \   / _ \
//					     | '_ \  | | | | | | | | | | | |
//					     | (_) | | |_| | | |_| | | |_| |
//					      \___/   \___/   \___/   \___/
//					    

//                             _            _                __
//  __/\__   ___    ___     __| |   ___    | |__    _   _   / _|
//  \    /  / __|  / _ \   / _` |  / _ \   | '_ \  | | | | | |_
//  /_  _\ | (__  | (_) | | (_| | |  __/   | |_) | | |_| | |  _|
//    \/    \___|  \___/   \__,_|  \___|   |_.__/   \__,_| |_|
////
//
// Data structure of the P-code
//      <-- 100 -->   <nxt>  PRINT  'var'  A      :      PRINT  'var'  B     'eol'
//	0000   0144   0011   7756   7777   0101   7775   7756   7777   0102   0000
//      LineHi LineLo Skip  <---------------------  opcodes  -------------------->
//
/[
CODE,
	0;12;16;tkPRIN;tkCONS;0;1;tkPLUS;tkCONS;0;2;tkPLUS;tkCONS;0;3;0	/ 10 PRINT 1+2+3
	0;24;15;tkLET;tkVAR;101;tkEQ;tkCONS;0;13;tkPLUS;tkCONS;1;1134;0	/ 20 LET A=11+4700
	0;36;11;tkLET;tkVAR;102;tkEQ;tkCONS;0;52;0			/ 30 LET B=42
	0;50;10;tkPRIN;tkVAR;101;tkSEMI;tkVAR;102;0			/ 40 PRINT A;B
	0;62;3;tkEND;0							/ 50 END
	7777



//					       __     ____     ___     ___
//					      / /_   |___ \   / _ \   / _ \
//					     | '_ \    __) | | | | | | | | |
//					     | (_) |  / __/  | |_| | | |_| |
//					      \___/  |_____|  \___/   \___/
//					    

//					       __     _  _      ___     ___
//					      / /_   | || |    / _ \   / _ \
//					     | '_ \  | || |_  | | | | | | | |
//					     | (_) | |__   _| | |_| | | |_| |
//					      \___/     |_|    \___/   \___/
//					    

//					       __      __      ___     ___
//					      / /_    / /_    / _ \   / _ \
//					     | '_ \  | '_ \  | | | | | | | |
//					     | (_) | | (_) | | |_| | | |_| |
//					      \___/   \___/   \___/   \___/
//					    					    

//					      _____    ___     ___     ___
//					     |___  |  / _ \   / _ \   / _ \
//					        / /  | | | | | | | | | | | |
//					       / /   | |_| | | |_| | | |_| |
//					      /_/     \___/   \___/   \___/
//					    

*7170
CODEND,	.
/]

*7200
//					      _____   ____     ___     ___
//					     |___  | |___ \   / _ \   / _ \
//					        / /    __) | | | | | | | | |
//					       / /    / __/  | |_| | | |_| |
//					      /_/    |_____|  \___/   \___/
//					    
//                                   _                __
//  __/\__ __   __   __ _   _ __    | |__    _   _   / _|
//  \    / \ \ / /  / _` | | '__|   | '_ \  | | | | | |_
//  /_  _\  \ V /  | (_| | | |      | |_) | | |_| | |  _|
//    \/     \_/    \__,_| |_|      |_.__/   \__,_| |_|
//
/[
VARBUF,	
TokBuf,	ZBLOCK 	10		/ Used for a bit of extra space when tokenizing 
				/ the key input buffer. The length of the 
				/ tokenized string can be longer than the raw
				/ string if there's a lot of 1 ot 2 digit
				/ constants in the line.

KBuf,	ZBLOCK	120		/ Keyboard input buffer 80(dec) bytes

AZvars,	ZBLOCK 	64		/ The A-Z variables 26*2(dec) bytes

/]


//                                         _                     _
//  __/\__     ___    ___    _ __    ___  | |_    __ _   _ __   | |_   ___
//  \    /    / __|  / _ \  | '_ \  / __| | __|  / _` | | '_ \  | __| / __|
//  /_  _\   | (__  | (_) | | | | | \__ \ | |_  | (_| | | | | | | |_  \__ \
//    \/      \___|  \___/  |_| |_| |___/  \__|  \__,_| |_| |_|  \__| |___/
//
/[
CONSTS,

CRLF,	15; 12; 0
Prmpt,	15; 12; ">; 0
SynErr,	15; 12; "E; "R; "R; "@; 0
BsSpBs,	10; 40; 10; 0

CmdTxt,
tkVAR=	 -1;	1		; tkVAR		/   Variable
tkCONS=	 -2;	2		; tkCONS	/   Constant
tkSTRI=  -3;	42		; tkSTRI	/ " String start/end
tkEQ= 	 -4;	ASCII "="	; tkEQ		/ Comparison
tkGTEQ=	 -5;	ASCII ">="	; tkGTEQ	/ Comparison
tkGT=	 -6;	ASCII ">"	; tkGT		/ Comparison
tkNE=	 -7;	ASCII "<>"	; tkNE		/ Comparison
tkLNEQ=	-10;	ASCII "<="	; tkLNEQ	/ Comparison
tkLT=	-11;	ASCII "<"	; tkLT		/ Comparison
tkPLUS=	-12;	ASCII "+"	; tkPLUS	/ 
tkMINU=	-13;	ASCII "-"	; tkMINU	/ 
tkMULT=	-14;	ASCII "*"	; tkMULT	/ 
tkDIVI=	-15;	ASCII "/"	; tkDIVI	/ 
tkLPAR=	-16;	ASCII "("	; tkLPAR	/ 
tkRPAR=	-17;	ASCII ")"	; tkRPAR	/ 
tkSEMI= -20;	ASCII ";"	; tkSEMI	/ Print space, no CRLF
tkCOMM= -21;	ASCII ","	; tkCOMM	/ Print in columns 
tkREM=	-22;	ASCII "REM"	; tkREM		/ Command - Ignore rest of line
tkCOLO=	-23;	ASCII ":"	; tkCOLO	/ Command - Ignore this and continue
tkLET=	-24;	ASCII "LET"	; tkLET		/ Command
tkINPU=	-25;	ASCII "INPUT"	; tkINPU	/ Command
tkGET=	-26;	ASCII "GET"	; tkGET		/ Command 
tkPRIN=	-27;	ASCII "PRINT"	; tkPRIN	/ Command
		ASCII "?"	; tkPRIN	/ Command
tkPRIQ=-30;	ASCII "XYZZY"	; tkPRIQ	/ Command
tkIF=	-31;	ASCII "IF"	; tkIF		/ Command
tkFOR=	-32;	ASCII "FOR"	; tkFOR		/ Command
tkNEXT=	-33;	ASCII "NEXT"	; tkNEXT	/ Command
tkGOTO=	-34;	ASCII "GOTO"	; tkGOTO	/ Command
tkGOSU=	-35;	ASCII "GOSUB"	; tkGOSU	/ Command
tkRETU=	-36;	ASCII "RETURN"	; tkRETU	/ Command
tkEND=	-37;	ASCII "END"	; tkEND		/ Command
tkTHEN=	-40;	ASCII "THEN"	; tkTHEN	/  
tkELSE=	-41;	ASCII "ELSE"	; tkELSE	/ 
tkTO=	-42;	ASCII "TO"	; tkTO		/ 
tkSTEP=	-43;	ASCII "STEP"	; tkSTEP	/ 
tkRND=	-44;	ASCII "RND"	; tkRND		/ 
tkABS=	-45;	ASCII "ABS"	; tkABS		/ 
tkCHR=	-46;	ASCII "CHR"	; tkCHR		/ 
tkRUN=	-47;	ASCII "RUN"	; tkRUN		/ Direct command
tkLIST=	-50;	ASCII "LIST"	; tkLIST	/ Direct command
tkNEW=	-51;	ASCII "NEW"	; tkNEW		/ Direct command
tkFREE=	-52;	ASCII "FREE"	; tkFREE	/ Direct command
	0					/ End-of-table marker

tkOFS1=  52;					/ Direct cmds offset
tkOFS2=  37;					/ Commands offset
tkOFS3=  11;					/ Comparisons offset

/]


//   ____                    ___            _
//  / ___|   _ __     ___   / _ \   _   _  | |_
//  \___ \  | '_ \   / __| | | | | | | | | | __|
//   ___) | | |_) | | (__  | |_| | | |_| | | |_
//  |____/  | .__/   \___|  \___/   \__,_|  \__|
//          |_|
/[
SpcOut,	0
	CLA
	TAD 	[40]
	JMS 	ChrOut
	JMP I	SpcOut
/]


//   _____          _      ___            _
//  |_   _| __  __ | |_   / _ \   _   _  | |_
//    | |   \ \/ / | __| | | | | | | | | | __|
//    | |    >  <  | |_  | |_| | | |_| | | |_
//    |_|   /_/\_\  \__|  \___/   \__,_|  \__|
//
// Print the text pointed to by the parameter. Calls ChrOut 
// for the actual outputting. Returns with AC and L cleared.
//
// Inputs: 	parameter
// Modifies: 	AC PrintP
// Outputs:
//
/[
TxtOut,	0
	CLA CLL
	TAD I	TxtOut          / Get address of parameter
	TAD	[-1]
	DCA	PrintP
	ISZ 	TxtOut		/ Bump up return address

TxtOu,
	CLA			/ Get character to print
	TAD I 	PrintP		
	SPA SNA			/ Return to caller if at end of message
	JMP I 	TxtOut		 
	JMS 	ChrOut		/ Call the character out for printing
	JMP 	TxtOu		/ Now do next character
/]

//   ____    _            ___            _
//  |  _ \  (_)   __ _   / _ \   _   _  | |_
//  | | | | | |  / _` | | | | | | | | | | __|
//  | |_| | | | | (_| | | |_| | | |_| | | |_
//  |____/  |_|  \__, |  \___/   \__,_|  \__|
//               |___/
//
// Outputs a number ranging between 0 and 9(dec) as a ASCII 
// character to the TTY.  Calls ChrOut for the actual outputting.
// Returns with AC and L cleared
//
// Inputs: 	AC
// Modifies: 	AC,L
// Outputs:
//
/[
DigOut,	0
	TAD	[60]		/ Convert number 0..9 to ASCII 0..9
	JMS	ChrOut		/ Call the ASCII printing function
	JMP I 	DigOut
/]


//    ____   _               ___            _
//   / ___| | |__    _ __   / _ \   _   _  | |_
//  | |     | '_ \  | '__| | | | | | | | | | __|
//  | |___  | | | | | |    | |_| | | |_| | | |_
//   \____| |_| |_| |_|     \___/   \__,_|  \__|
//
// Output the data in AC to the TTY and wait for the TTY
// to become ready again. Clears AC and L before returning
//
// Inputs: 	AC
// Modifies: 	AC,L
// Outputs:
//
/[
ChrOut,	0 
	TLS		/ Send to TTY
	TSF		/ Wait for TTY to become ready
	JMP	.-1
	CLA CLL		/ Clear AC and L
	JMP I	ChrOut
/]


//     ____          _     _  __
//    / ___|   ___  | |_  | |/ /   ___   _   _
//   | |  _   / _ \ | __| | ' /   / _ \ | | | |
//   | |_| | |  __/ | |_  | . \  |  __/ | |_| |
//    \____|  \___|  \__| |_|\_\  \___|  \__, |
//                                       |___/
//
// Wait for a character to arrive from the TTY, mask off the parity, store it in 'Key'
// and also return it in AC
//
// Inputs: 
// Modifies: 	AC
// Outputs:	Key
//
/[
GetKey,	0
	KSF     		/ Spin here until a character is available
		JMP 	.-1	
		KRB     		/ Read character
	AND 	[177]		/ Only keep the 7 lowest bits
	DCA	Key		/ Save the read character in Key
	TAD	Key		/ Return with the character in AC as well
	JMP I 	GetKey
/]







//   ____                    _
//  / ___|   _   _   _ __   | |_    __ _  __  __
//  \___ \  | | | | | '_ \  | __|  / _` | \ \/ /
//   ___) | | |_| | | | | | | |_  | (_| |  >  <
//  |____/   \__, | |_| |_|  \__|  \__,_| /_/\_\
//           |___/
/[
Syntax,	JMS 	TxtOut; SynErr
	JMS I	IntOut; lineH
	JMS	TxtOut; CRLF
	JMP I	Prompt

/]


//					      _____   _  _      ___     ___
//					     |___  | | || |    / _ \   / _ \
//					        / /  | || |_  | | | | | | | |
//					       / /   |__   _| | |_| | | |_| |
//					      /_/       |_|    \___/   \___/
//					    

//					      _____    __      ___     ___
//					     |___  |  / /_    / _ \   / _ \
//					        / /  | '_ \  | | | | | | | |
//					       / /   | (_) | | |_| | | |_| |
//					      /_/     \___/   \___/   \___/


*7755
/[
MEMEND,			/ Last address before RIM loader
	ZBLOCK 22
/]

$

